## 2.1 `Observable` 클래스

- [옵저버 패턴](https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4)을 구현

- 객체의 상태를 관찰하는 옵저버 등록

- 객체의 상태가 변할 때마다 옵저버에 알림

- 라이프 사이클 __없음__

- 보통 __단일 함수__로 변화를 알림 (ex. Android `onClick()`)

- RxJava의 `Observable`은 __세 가지__ 알림을 구독자에게 알림

  - `onNext`: `Observable`이 데이터의 발행을 알림
  - `onComplete`: 모든 데이터의 발행을 완료했음을 알림. 단 한 번 실행 (더 이상 `onNext` 이벤트가 발생하면 안됨)
  - `onError`: `Observable`이 어떠한 이유로 에러가 발생했음을 알림. 이후 `onNext` 및 `onComplete`가 발생하지 않음 (`Observable` 종료)

- __함수 종류__

  - `Observable`을 생성하는 __팩토리 함수__

    | 팩토리 함수                               | 함수                                       |
    | ------------------------------------ | ---------------------------------------- |
    | RxJava 1.x 기본 팩토리 함수                 | create(), just(), from()                 |
    | RxJava 2.x 추가 팩토리 함수 (from() 함수 세분화) | fromArray(), fromIterable(), fromCallable(), fromFuture(), fromPublisher() |
    | 기타 팩토리 함수                            | interval(), range(), timer(), defer() 등  |

  - __중간 결과를 처리하는 함수__
  - __디버그 및 예외 처리 함수__

### 2.1.1 `just()` 함수

- 데이터를 발행하는 가장 쉬운 방법은 기존의 자료구조를 사용하는 것

- `just()` 함수는 인자로 넣은 데이터를 차례로 발행하려고 `Observable`을 생성
  (실제 데이터 발행은 `subscribe()` 함수 호출해야 시작)

- 원형

  ```java
  public static <T> Observable<T> just(T item);
  public static <T> Observable<T> just(T item1, T item2);
  ...
  public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10);
  ```


- 예제

  ```Java
  public class FirstExample {
  	public void emit() {
  		Observable
  			.just(1, 2, 3, 4, 5, 6)
  			.subscribe(System.out::println);
  	}
  }
  ```

### 2.1.2 `subscribe()` 함수와 `Disposable` 객체

- RxJava는 원하는 동작을 미리 정의하고 원하는 시점에 실행 가능

- 정의는 __팩토리 함수__로 실행은 `subscribe()` 함수로 함

- `subscribe()` 함수 원형

  ```java
  Disposable subscribe();
  Disposable subscribe(Consumer<? super T> onNext);
  Disposable subscribe(Consumer<? super T> onNext, Consumer<? super java.lang.Throwable> onError);
  Disposable subscribe(Consumer<? super T> onNext, Consumer<? super java.lang.Throwable> onError, Action onComplete);
  ```

  - 인자 없는 `subscribe()` 함수는 __테스트 or 디버깅__할 때 활용
  - `onError`가 없는 `subscribe()` 함수의 경우 `OnErrorNotImplementedException` 발생

- `Disposable` 인터페이스 함수

  ```java
  void dispose();
  boolean isDisposed();
  ```

  - `Disposable`은 RxJava 1.x의 __구독 객체__

- 예제

  ```java
  Observable<String> source = Observable.just("RED", "GREEN", "YELLOW");
  Disposable d = source.subscribe(
  	v -> System.out.println("onNext() : value : " + v)),
  	err -> System.err.println("onError() : err : " + err.getMessage()),
  	() -> System.out.println("onComplete()"));

  System.out.println("isDisposed() : " + d.isDisposed());
  ```

### 2.1.3 `create()` 함수

- `create()` 함수는 `onNext`, `onComplete`, `onError`를 개발자가 직접 호출해야 함 (`just()`__의 경우 자동 호출__)

- 원형

  ```java
  Observable<T> create(ObservableOnSubscribe<T> source);
  ```

- `ObservableOnSubscribe` 인터페이스 함수

  ```java
  public interface ObservableOnSubscribe<T> {
  	void subscribe(ObservableEmiiter<T> e) throws Exception;
  }
  ```

- 예제

  ```java
  Observable<Integer> source = Observable.create(
  	ObservableEmiiter<Integer> emitter -> {
  		emitter.onNext(100);
  		emitter.onNext(200);
  		emitter.onNext(300);
  		emitter.onComplete();
  	});
  source.subscribe(System.out::println);
  ```

  - `System.out::println`은 `data -> System.out.println(data)` 코드를 줄인 것 (__메서드 레퍼런스__)

- __주의사항__

  - `create()` 함수는 RxJava에 익숙한 개발자만 활용하도록 권고함 > 다른 팩토리 함수로 같은 효과를 낼 수 있음
  - 사용 시, 아래 사항을 꼭 확인할 것
    1. `Observable`이 해지(dispose)되었을 때 등록된 콜백을 모두 해제해야 함 > 잠재적인 __메모리 누수__ 발생
    2. 구독자가 구독하는 동안만 `onNext`와 `onComplete`를 호출해야 함
    3. 에러가 발생했을 때는 오직 `onError`로만 전달해야 함
    4. 배압을 직접 처리해야 함

### 2.1.4 `fromArray()` 함수

- `just()` 함수나 `create()` 함수는 단일 데이터만 다룸

- `fromXXX()` 함수는 단일 데이터가 아닐 때 사용

  - RxJava 1.x에서는 `from()` 함수와 `fromCallable()` 함수만 사용했음
  - `from()` 함수의 모호함으로 인해 분리됨

- `fromArray()` 함수는 배열 데이터를 처리

- 예제

  ```java
  Integer[] arr = { 100, 200, 300 };
  Observable<Integer> source = Observable.fromArray(arr);
  source.subscribe(System.out::println);
  ```

  - __Primitive Type의 배열__은 아래와 같이 처리함

    ```java
    int[] intArray = { 400, 500, 600 };
    Observable<Integer> source = Observable.fromArray(toIntegerArray(intArray));
    source.subscribe(System.out::println);

    private static Integer[] toIntegerArray(int[] intArray) {
    	return IntStream.of(intArray).boxed().toArray(Integer[]::new);
    }
    ```

### 2.1.5 `fromIterable()` 함수

- `fromIterable()` 함수는 `Iterator`를 구현한 데이터를 처리

- 예제

  ```java
  List<String> names = new ArrayList<>();
  names.add("Jerry");
  names.add("William");
  names.add("Bob");

  Observable<String> source = Observable.fromIterable(names);
  source.subscribe(System.out::println);
  ```

  ```java
  Set<String> cities = new HashSet<>();
  cities.add("Seoul");
  cities.add("London");
  cities.add("Paris");

  Observable<String> source = Observable.fromIterable(cities);
  source.subscribe(System.out::println);
  ```

  ```java
  BlockingQueue<Order> orderQueue = new ArrayBlockingQueue<>(100);
  orderQueue.add(new Order("ORD-1"));
  orderQueue.add(new Order("ORD-2"));
  orderQueue.add(new Order("ORD-3"));

  Observable<Order> source = Observable.fromIterable(orderQueue);
  source.subscribe(order -> System.out.println(order.getId()));

  public class Order {
  	private String id;

  	// ...

  	public String getId() {
  		return id;
  	}

  	// ...
  }
  ```

  - `Map`의 경우 `Iterator`를 구현하지 않았기 때문에 라이브러리를 사용하거나 직접 만들어야 함

### 2.1.6 `fromCallable()` 함수

- `Callable` 인터페이스는 자바 5에 추가된 __동시성 API__로 비동기 계산의 결과를 반환

- `Callable` 인터페이스

  ```java
  public interface Callable<V> {
  	V call() throws Exception;
  }
  ```

- `Runnable` 인터페이스와 다르게 실행 결과를 리턴함

- `Executor` 인터페이스의 인자로 활용되기 때문에 잠재적으로 다른 스레드에서 실행 됨을 의미

- 예제

  ```java
  Callable<String> callable = () -> {
  	Thread.sleep(1000);
  	return "Hello Callable";
  };
  Observable<String> source = Observable.fromCallable(callable);
  source.subscribe(System.out::println);
  ```

### 2.1.7 `fromFuture()` 함수

- `Future` 인터페이스 자바 5에 추가된 __동시성 API__로 비동기 계산의 결과를 구할 때 사용

- 보통 `Executor` 인터페이스를 구현한 클래스에 `Callable` 객체를 인자로 넣어 `Future` 객체를 반환

- 예제

  ```java
  Future<String> future = Executors.newSingleThreadExecutor().submit(() -> {
  	Thread.sleep(1000);
  	return "Hello Future";
  });
  Observable<String> source = Observable.fromFuture(future);
  source.subscribe(System.out::println);
  ```

- `Executor`는 다양한 스레드풀을 지원

- RxJava는 RxJava에서 제공하는 스케줄러를 사용하도록 권장함 (5장에서 자세히)

### 2.1.8 `fromPublisher()` 함수

- 자바 9의 표준인 __Flow API__의 일부

- 예제

  ```java
  Publisher<String> publisher = (Subscriber<? super String> s) -> {
  	s.onNext("Hello Observable.fromPublisher()");
  	s.onComplete();
  };
  Observable<String> source = Observable.fromPublisher(publisher);
  source.subscribe(System.out::println);
  ```




## 2.2 `Single` 클래스

- RxJava 1.x부터 존재하는 `Observable`의 특수한 형태
- __단 하나의 데이터만 발행__하도록 한정
- 보통 결과가 유일한 서버 API를 호출할 때 유용하게 사용
- __중요__
  - 데이터 하나 발행과 동시에 종료
  - 라이프 사이클 함수는 `onSuccess()`와 `onError()` 두 가지
  - 라이프 사이클 관점에서 `onSuccess()` = `onNext()` + `onComplete()`

### 2.2.1 `just()` 함수

```java
Single<String> source = Single.just("Hello Single");
source.subscribe(System.out::println);
```

- `Observable` 클래스의 `just()` 함수와 유사함

```
Hello Single
```

### 2.2.2 `Observable`에서 `Single` 클래스 사용

- 기존 `Observable`에서 `Single` 객체로 변환하기

  ```java
  Observable<String> source = Observable.just("Hello Single");
  Single
  	.fromObservable(source)
  	.subscribe(System.out::println);
  ```
  - `fromObservable()` 함수를 사용

- `single()` 함수를 호출해 `Single` 객체 생성하기

  ```java
  Observable
  	.just("Hello Single")
  	.single("default item")
  	.subscribe(System.out::println);
  ```

  - `Observable` 클래스의 `single()` 함수를 사용
  - `Observable`에서 값이 발행되지 않아도 `single()` 함수에 넣은 기본 인자를 대신 발행함

- `first()` 함수를 호출해 `Single` 객체 생성하기

  ```java
  String[] colors = {"Red", "Blue", "Gold"};
  Observable
  	.fromArray(colors)
  	.first("default value")
  	.subscribe(System.out::println);
  ```

  - 여러 개의 데이터를 발행할 수 있는 `Observable`의 경우 `first()` 함수로 `Single` 객체 변환

- empty `Observable`에서 `Single` 객체 생성하기

  ```java
  Observable
  	.empty()
  	.single("defaultv value")
  	.subscribe(System.out::println);
  ```

  - 빈 값을 발행 할때도 `single()` 함수를 사용해 변환 가능
  - `single()` 함수의 기본 값이 대신 발행됨

- `take()` 함수에서 `Single` 객체 생성하기

  ```java
  Observable
  	.just(new Order("ORD-1"), new Order("ORD-2"))
  	.take(1)
  	.single(new Order("default order"))
  	.subscribe(System.out::println);
  ```

  - `take()` 함수를 통해 `Single` 객체를 생성하는 방법 (3장에서 설명)

- 결과

  ```
  Hello Single
  Hello Single
  Red
  deafult value
  Order ID: ORD-1
  ```

### 2.2.3 `Single` 클래스의 올바른 사용 방법

- `just()` 함수에 여러 개의 값을 넣을 경우 `Exception` 발생

  ```java
  Single<String> source = Observable
  	.just("Hello Single", "Error").single("default item");
  source.subscribe(System.out::println);
  ```

  ```java
  java.langIllegalArgumentException: Sequnce contains more than one element!
  	at io. reactivex.internal.operators.observable.ObservableSingleSingle$SingleElementObserver.onNext(ObservableSingleSingle.java:82)
  	at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java:105)
  	at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java:35)
  	at io.reactivex.Observable.subscribe(Observable.java:10514)
    	at io.reactivex.internal.operators.observable.ObservableSingleSingle.subscribleActual(ObservableSingleSingle.java:35)
  	at io.reactivex.Single.subscribe(Single.java:2656)
  	at io.reactivex.Single.subscribe(Single.java:2642)
  	at io.reactivex.Single.subscribe(Single.java:2613)
  	...
  ```

  ​

## 2.3 `Maybe` 클래스

- `Observable`의 또다른 특수한 형태
- 0개 혹은 1개 데이터를 발생 완료할 수 있음
- `Single` 클래스에 `onComplete` 이벤트가 추가된 형태
- `Maybe` 객체를 생성할 수 있는 __리액티브 연산자__
  - `elementAt()`
  - `firstElement()`
  - `flatMapMaybe()`
  - `lastElement()`
  - `reduce()`
  - `singleElement()`



## 2.4 뜨거운 `Observable`

- `Observable`에는 두 가지 종류가 있음
  - __뜨거운__ `Observable`
  - __차가운__ `Observable`
- __차가운__ `Observable`
  - 지금까지 배운 `Observable`
  - 즉 `Observable`의 기본은 __차가운__ `Observable`
  - 옵저버가 구독하지 않으면 __데이터를 발행하지 않음__ (게으른 접근법)
  - 예는 __웹 요청, 데이터베이스 쿼리와 파일 읽기 등__
- __뜨거운__ `Observable`
  - 구독자의 구독과 관계없이 데이터를 발행하는 `Observable`
  - 여러 구독자를 고려할 수 있음
  - 구독자는 처음부터 모든 데이터를 수신한다는 보장은 없음
  - 예는 __마우스, 키보드, 시스템, 센서 이벤트와 주식 가격 등__
  - __배압__을 주의해야 함 (8장)
    `Observable`에서 데이터를 발행하는 속도와 구독자가 처리하는 속도의 차이가 클 때 발생
- `Subject`, `ConnectableObservable` 클래스
  - __차가운__ `Observable`을 __뜨거운__ `Observable`로 변환하게 도와줌



## 2.5 `Subject` 클래스

- __차가운__ `Observable`을 __뜨거운__ `Observable`로 변환

- `Observable`의 속성과 __구독자__의 속정 모두 가지고 있음 (데이터 발행 & 데이터 처리)

  ```java
  public abstract class Subject<T> extends Observable<T> implements Observer<T>
  ```

  - `Obervable`를 상속하면서 동시에 `Observer`를 구현하고 있기 때문에 가능

- 주요 클래스

  - `AsyncSubject`
  - `BehaviorSubject`
  - `PublishSubject`
  - `ReplaySubject`
  - `CompletableSubject`
  - `MaybeSubject`
  - `SingleSubject`
  - `UnicastSubject`

### 2.5.1 `AsyncSubject` 클래스

- __완료되기 전 마지막 데이터만 관심__이 있고 이전 데이터는 무시함

- 사용 예

  ```java
  AsyncSubject<String> subject = AsyncSubject.create();
  subject.subscribe(data -> System.out.println("Subscriber #1 => " + data));
  subject.onNext("1");
  subject.onNext("3");
  subject.subscribe(data -> System.out.println("Subscriber #2 => " + data));
  subject.onNext("5");
  subject.onComplete();
  ```

- 결과

  ```
  Subscriber #1 => 5
  Subscriber #2 => 5
  ```

- 구독자로 동작하는 예

  ```java
  Float[] temprature = { 10.1f, 13.4f, 12.5f };
  Observable<Float> source = Observable.fromArray(temperature);

  AsyncSubject<Float> subject = AsyncSubject.create();
  subject.subscribe(data -> System.out.println("Subscriber #1 => " + data));

  source.subscribe(subject);
  ```

- 결과

  ```
  Subscriber #1 => 12.5
  ```

### 2.5.2 `BehaviorSubject` 클래스

- 구독자에게 __가장 최근 값 혹은 기본 값__을 넘겨줌

- 사용 예

  ```java
  BehaviorSubject<String> subject = BehaviorSubject.createDefault("6");
  subject.subscribe(data -> System.out.println("Subscriber #1 => " + data));
  subject.onNext("1");
  subject.onNext("3");
  subject.subscribe(data -> System.out.println("Subscriber #2 => " + data));
  subject.onNext("5");
  subject.onComplete();
  ```

- 결과

  ```
  Subscriber #1 => 6
  Subscriber #1 => 1
  Subscriber #1 => 3
  Subscriber #2 => 3
  Subscriber #1 => 5
  Subscriber #2 => 5
  ```

### 2.5.3 `PublishSubject` 클래스

- 가장 평범한 `Subject` 클래스

- 구독자가 `subscribe()` 함수를 호출하면 값을 발행

- 사용 예

  ```java
  PublishSubject<String> subject = PublishSubject.create();
  subject.subscribe(data -> System.out.println("Subscriber #1 => " + data));
  subject.onNext("1");
  subject.onNext("3");
  subject.subscribe(data -> System.out.println("Subscriber #2 => " + data));
  subject.onNext("5");
  subject.onComplete();
  ```

- 결과

  ```
  Subscriber #1 => 1
  Subscriber #1 => 3
  Subscriber #1 => 5
  Subscriber #2 => 5
  ```

### 2.5.4 `ReplaySubject` 클래스

- 가장 특이하면서 __사용시 주의해야 함__ (__뜨거운__ `Observable`인데 __차가운__ `Observable`처럼 동작)

- 구독자가 새로 생기면 항상 데이터의 처음부터 끝까지 발행

- 모든 데이터의 내용을 저장하는 과정 중 __메모리 누수__가 발생할 가능성을 염두해 두어야 함

- 사용 예

  ```java
  ReplaySubject<String> subject = ReplaySubject.create();
  subject.subscribe(data -> System.out.println("Subscriber #1 => " + data));
  subject.onNext("1");
  subject.onNext("3");
  subject.subscribe(data -> System.out.println("Subscriber #2 => " + data));
  subject.onNext("5");
  subject.onComplete();
  ```

- 결과

  ```
  Subscriber #1 => 1
  Subscriber #1 => 3
  Subscriber #2 => 1
  Subscriber #2 => 3
  Subscriber #1 => 5
  Subscriber #2 => 5
  ```



## 2.6 `ConnectableObservable` 클래스

- __차가운__ `Observable`을 __뜨거운__ `Observable`로 변환

- 구독자가 `subscribe()` 함수를 호출해도 데이터 발행이 일어나지 않음

- `connect()` 함수를 호출하면 `subscribe()` 함수를 호출한 구독자에게 데이터 발행

- 사용 예

  ```java
  String[] dt = { "1", "3", "5" };
  Observable<String> balls = Observable.interval(100L, TimeUnit.MIILISECONDS)
  	.map(Long::intValue)
  	.map(i -> dt[i])
  	.take(dt.length);
  ConnectableObservable<String> source = balls.publish();
  source.subscribe(data -> System.out.println("Subscriber #1 => " + data));
  source.subscribe(data -> System.out.println("Subscriber #2 => " + data));
  source.connect();

  CommonUtils.sleep(250);
  source.subscribe(data -> System.out.println("Subscriber #3 => " + data));
  CommonUtils.sleep(100);
  ```

  - `publish()` 함수는 `connect()` 함수가 호출되기 전까지 데이터 발행을 __유예__

- 결과

  ```
  Subscriber #1 => 1
  Subscriber #2 => 1
  Subscriber #1 => 3
  Subscriber #2 => 3
  Subscriber #1 => 5
  Subscriber #2 => 5
  Subscriber #3 => 5
  ```

  ​