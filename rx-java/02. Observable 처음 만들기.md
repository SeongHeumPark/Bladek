## 2.1 `Observable` 클래스

- [옵저버 패턴](https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4)을 구현

- 객체의 상태를 관찰하는 옵저버 등록

- 객체의 상태가 변할 때마다 옵저버에 알림

- 라이프 사이클 __없음__

- 보통 __단일 함수__로 변화를 알림 (ex. Android `onClick()`)

- RxJava의 `Observable`은 __세 가지__ 알림을 구독자에게 알림

  - `onNext`: `Observable`이 데이터의 발행을 알림
  - `onComplete`: 모든 데이터의 발행을 완료했음을 알림. 단 한 번 실행 (더 이상 `onNext` 이벤트가 발생하면 안됨)
  - `onError`: `Observable`이 어떠한 이유로 에러가 발생했음을 알림. 이후 `onNext` 및 `onComplete`가 발생하지 않음 (`Observable` 종료)

- __함수 종류__

  - `Observable`을 생성하는 __팩토리 함수__

    | 팩토리 함수                               | 함수                                       |
    | ------------------------------------ | ---------------------------------------- |
    | RxJava 1.x 기본 팩토리 함수                 | create(), just(), from()                 |
    | RxJava 2.x 추가 팩토리 함수 (from() 함수 세분화) | fromArray(), fromIterable(), fromCallable(), fromFuture(), fromPublisher() |
    | 기타 팩토리 함수                            | interval(), range(), timer(), defer() 등  |

  - __중간 결과를 처리하는 함수__
  - __디버그 및 예외 처리 함수__

### 2.1.1 `just()` 함수

- 데이터를 발행하는 가장 쉬운 방법은 기존의 자료구조를 사용하는 것

- `just()` 함수는 인자로 넣은 데이터를 차례로 발행하려고 `Observable`을 생성
  (실제 데이터 발행은 `subscribe()` 함수 호출해야 시작)

- 원형

  ```java
  public static <T> Observable<T> just(T item);
  public static <T> Observable<T> just(T item1, T item2);
  ...
  public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10);
  ```


- 예제

  ```Java
  public class FirstExample {
  	public void emit() {
  		Observable
  			.just(1, 2, 3, 4, 5, 6)
  			.subscribe(System.out::println);
  	}
  }
  ```

### 2.1.2 `subscribe()` 함수와 `Disposable` 객체

- RxJava는 원하는 동작을 미리 정의하고 원하는 시점에 실행 가능

- 정의는 __팩토리 함수__로 실행은 `subscribe()` 함수로 함

- `subscribe()` 함수 원형

  ```java
  Disposable subscribe();
  Disposable subscribe(Consumer<? super T> onNext);
  Disposable subscribe(Consumer<? super T> onNext, Consumer<? super java.lang.Throwable> onError);
  Disposable subscribe(Consumer<? super T> onNext, Consumer<? super java.lang.Throwable> onError, Action onComplete);
  ```

  - 인자 없는 `subscribe()` 함수는 __테스트 or 디버깅__할 때 활용
  - `onError`가 없는 `subscribe()` 함수의 경우 `OnErrorNotImplementedException` 발생

- `Disposable` 인터페이스 함수

  ```java
  void dispose();
  boolean isDisposed();
  ```

  - `Disposable`은 RxJava 1.x의 __구독 객체__

- 예제

  ```java
  Observable<String> source = Observable.just("RED", "GREEN", "YELLOW");
  Disposable d = source.subscribe(
  	v -> System.out.println("onNext() : value : " + v)),
  	err -> System.err.println("onError() : err : " + err.getMessage()),
  	() -> System.out.println("onComplete()"));

  System.out.println("isDisposed() : " + d.isDisposed());
  ```

### 2.1.3 `create()` 함수

- `create()` 함수는 `onNext`, `onComplete`, `onError`를 개발자가 직접 호출해야 함 (`just()`__의 경우 자동 호출__)

- 원형

  ```java
  Observable<T> create(ObservableOnSubscribe<T> source);
  ```

- `ObservableOnSubscribe` 인터페이스 함수

  ```java
  public interface ObservableOnSubscribe<T> {
  	void subscribe(ObservableEmiiter<T> e) throws Exception;
  }
  ```

- 예제

  ```java
  Observable<Integer> source = Observable.create(
  	ObservableEmiiter<Integer> emitter -> {
  		emitter.onNext(100);
  		emitter.onNext(200);
  		emitter.onNext(300);
  		emitter.onComplete();
  	});
  source.subscribe(System.out::println);
  ```

  - `System.out::println`은 `data -> System.out.println(data)` 코드를 줄인 것 (__메서드 레퍼런스__)

- __주의사항__

  - `create()` 함수는 RxJava에 익숙한 개발자만 활용하도록 권고함 > 다른 팩토리 함수로 같은 효과를 낼 수 있음
  - 사용 시, 아래 사항을 꼭 확인할 것
    1. `Observable`이 해지(dispose)되었을 때 등록된 콜백을 모두 해제해야 함 > 잠재적인 __메모리 누수__ 발생
    2. 구독자가 구독하는 동안만 `onNext`와 `onComplete`를 호출해야 함
    3. 에러가 발생했을 때는 오직 `onError`로만 전달해야 함
    4. 배압을 직접 처리해야 함

### 2.1.4 `fromArray()` 함수

- `just()` 함수나 `create()` 함수는 단일 데이터만 다룸

- `fromXXX()` 함수는 단일 데이터가 아닐 때 사용

  - RxJava 1.x에서는 `from()` 함수와 `fromCallable()` 함수만 사용했음
  - `from()` 함수의 모호함으로 인해 분리됨

- `fromArray()` 함수는 배열 데이터를 처리

- 예제

  ```java
  Integer[] arr = { 100, 200, 300 };
  Observable<Integer> source = Observable.fromArray(arr);
  source.subscribe(System.out::println);
  ```

  - __Primitive Type의 배열__은 아래와 같이 처리함

    ```java
    int[] intArray = { 400, 500, 600 };
    Observable<Integer> source = Observable.fromArray(toIntegerArray(intArray));
    source.subscribe(System.out::println);

    private static Integer[] toIntegerArray(int[] intArray) {
    	return IntStream.of(intArray).boxed().toArray(Integer[]::new);
    }
    ```

### 2.1.5 `fromIterable()` 함수

- `fromIterable()` 함수는 `Iterator`를 구현한 데이터를 처리

- 예제

  ```java
  List<String> names = new ArrayList<>();
  names.add("Jerry");
  names.add("William");
  names.add("Bob");

  Observable<String> source = Observable.fromIterable(names);
  source.subscribe(System.out::println);
  ```

  ```java
  Set<String> cities = new HashSet<>();
  cities.add("Seoul");
  cities.add("London");
  cities.add("Paris");

  Observable<String> source = Observable.fromIterable(cities);
  source.subscribe(System.out::println);
  ```

  ```java
  BlockingQueue<Order> orderQueue = new ArrayBlockingQueue<>(100);
  orderQueue.add(new Order("ORD-1"));
  orderQueue.add(new Order("ORD-2"));
  orderQueue.add(new Order("ORD-3"));

  Observable<Order> source = Observable.fromIterable(orderQueue);
  source.subscribe(order -> System.out.println(order.getId()));

  public class Order {
  	private String id;

  	// ...

  	public String getId() {
  		return id;
  	}

  	// ...
  }
  ```

  - `Map`의 경우 `Iterator`를 구현하지 않았기 때문에 라이브러리를 사용하거나 직접 만들어야 함

### 2.1.6 `fromCallable()` 함수

- `Callable` 인터페이스는 자바 5에 추가된 __동시성 API__로 비동기 계산의 결과를 반환

- `Callable` 인터페이스

  ```java
  public interface Callable<V> {
  	V call() throws Exception;
  }
  ```

- `Runnable` 인터페이스와 다르게 실행 결과를 리턴함

- `Executor` 인터페이스의 인자로 활용되기 때문에 잠재적으로 다른 스레드에서 실행 됨을 의미

- 예제

  ```java
  Callable<String> callable = () -> {
  	Thread.sleep(1000);
  	return "Hello Callable";
  };
  Observable<String> source = Observable.fromCallable(callable);
  source.subscribe(System.out::println);
  ```

### 2.1.7 `fromFuture()` 함수

- `Future` 인터페이스 자바 5에 추가된 __동시성 API__로 비동기 계산의 결과를 구할 때 사용

- 보통 `Executor` 인터페이스를 구현한 클래스에 `Callable` 객체를 인자로 넣어 `Future` 객체를 반환

- 예제

  ```java
  Future<String> future = Executors.newSingleThreadExecutor().submit(() -> {
  	Thread.sleep(1000);
  	return "Hello Future";
  });
  Observable<String> source = Observable.fromFuture(future);
  source.subscribe(System.out::println);
  ```

- `Executor`는 다양한 스레드풀을 지원

- RxJava는 RxJava에서 제공하는 스케줄러를 사용하도록 권장함 (5장에서 자세히)

### 2.1.8 `fromPublisher()` 함수

- 자바 9의 표준인 __Flow API__의 일부

- 예제

  ```java
  Publisher<String> publisher = (Subscriber<? super String> s) -> {
  	s.onNext("Hello Observable.fromPublisher()");
  	s.onComplete();
  };
  Observable<String> source = Observable.fromPublisher(publisher);
  source.subscribe(System.out::println);
  ```

  ​