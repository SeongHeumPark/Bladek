## 오류 처리

### 오류 코드보다 예외를 사용하라

- __오류 코드__보다 __예외__가 더 깔끔한 코드를 만듦
- __예외__ 별로 __다른 처리__를 할 수 있음

### `try`-`catch`-`finally`문부터 작성하라

- __범위__를 __정의__
- __예외가 발생할 코드__는 `try`-`catch`-`finally` 문으로 __시작하는 편이 나음__

### 미확인 예외를 사용하라

- __확인된 예외__는 __OCP__를 __위반__
  - __확인된 예외 하나가 추가__될 때마다 __관련된 호출자들을 모두 수정__해야 함
- __미확인 예외__만으로 안정적인 시스템 구현 가능

### 예외에 의미를 제공하라

- 모든 예외에 __호출 스택 제공__
- __발생 원인__과 __위치__를 __찾기 쉬워짐__

### 호출자를 고려해 예외 클래스를 정의하라

- 다양한 예외로 분류하는 것보다 __어떻게 오류를 잡아낼 지__가 더 __중요__

- 일반적인 예외 처리 방식

  - 예외 발생 → 예외 내용을 기록 → 정상 수행할 것인가

- 만약, __다양한 예외__에 __처리는 내용이 비슷__하다면 __Wrapper__ 클래스를 __사용__할 것

  ```java
  public class LocalPort {
  	private ACMEPort innerPort;

  	public LocalPort(int portNumber) {
      	innerPort = new ACMEPort(portNumber);
  	}

  	public void open() {
      	try {
          	innerPort.open();
      	} catch (DeviceResponseException e) {
          	throw enw PortDeviceFailure(e);
      	} catch (ATM1212UnlockedException e) {
          	throw enw PortDeviceFailure(e);
      	} catch (GMXError e) {
          	throw enw PortDeviceFailure(e);
      	}
  	}
  }
  ```

### 정상 흐름을 정의하라

- __특수 사례 패턴__
  __클래스를 만들거나 객체를 조작__해 __특수 사례__를 처리하는 방식
- __Head First Design Pattern__ 책의 __Composite 패턴__ 장에 나오는 내용
  - __컴포지트__에 __이터레이터__를 활용하면서 __다음 값이 없는 상황 발생__
  - `null`을 __반환__할 것이냐? __No__
  - 책에서는 `NullIterator` 클래스의 객체를 __반환(특수 객체)__

### `null`을 반환하지 마라

- __호출자__에게 __책임 전가__
  `null` 체크를 하기 위한 코드가 늘어남

- `null` 대신 __특수 사례 객체__를 반환하라

  ```java
  List<Employee> employees = getEmployees();
  for (Employee e : employees) {
  	totalPay += e.getPay();
  }

  // null을 반환하는 코드
  public List<Employee> getEmployees() {
  	if (..직원이 없다면..) {
      	return null;
  	}
  }

  // null 대신 빈 리스트(특수 사례 객체)를 반환하는 코드
  public List<Employee> getEmployees() {
  	if (..직원이 없다면..) {
      	return Collections.emptyList();
  	}
  }
  ```

  - __호출자__에서 `null` 체크를 할 필요가 없음
    즉, `NullPointerException` 발생 가능성이 줄어듦

### `null`을 전달하지 마라

- `null` 반환보다 더 나쁨

- 정상적인 인수로 `null`을 기대하는 API가 아니라면 지양

- `null` 인자 처리 방법

  - __새로운 예외 유형__ 던지기

    ```java
    public class MetricsCalculator {
    	public double xProjection(Point p1, Point p2) {
        	if (p1 == null || p2 == null) {
            	throw InvalidArgumentException("Invalid argument for MetricsCalculator.xProjection");
        	}
        
        	return (p2.x - p1.x) * 1.5;
    	}
    }
    ```

    - __호출자__에서 __새로운 예외 유형__에 대한 __처리기 필요__

  - `assert` 문 사용

    ```java
    public class MetricsCalculator {
    	public double xPorjection(Point p1, Point p2) {
        	assert p1 != null : "p1 should not be null";
        	assert p2 != null : "p2 should not be null";
        
        	return (p2.x - p1.x) * 1.5;
    	}
    }
    ```

    - 여전히 __실행오류 발생__

  - 애초에 `null`을 __인자로 넘기지 못하도록 금지__하는 __정책이 합리적__

### 정리

- __뭔가 잘못된 가능성__은 항상 존재
- __읽기__도 좋아야 하지만, __안정성__도 높아야 비로소 __깨끗한 코드__
- __오류 처리__를 __프로그램 논리__와 __분리__
  __튼튼하고 깨끗한 코드 작성 가능__