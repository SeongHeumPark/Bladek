## 04. 클래스와 객체

### 클래스

- OOP의 핵심 구성 요소

#### 클래스 선언

- `class` 키워드 사용

  ```kotlin
  class Person
  ```

- 인스턴스 생성

  ```java
  Person person = new Person() // 자바에서 코틀린 클래스 사용할 때
  ```

  ```kotlin
  var person = Person()
  ```



### 속성

- 필드 + 접근자(게터/세터)

- __최상위 or 멤버__로 정의 가능

- 아래에 규칙을 설계 원칙으로 함

  - 외부 API를 변경하지 않고 내부 구현을 변경할 수 있다.
  - 고정을 강제한다.
  - 멤버에 접근할 때 추가 작업을 수행할 수 있다.

  ```kotlin
  // 가장 기본적인 형태
  class Person {
      var name: String
      var age: Int
      
      constructor(name: String, age: Int) {
          this.name = name
          this.age = age
      }
  }
  ```

  ```kotlin
  // 주 생성자를 클래스 선언 부에 옮기고 init 블록 사용
  class Person constructor(name: String, age: Int) {
      var name: String
      var age: Int
      
      init {
          this.name = name
          this.age = age
          println("Person instance created")
      }
  }
  ```

  ```kotlin
  // init 블록을 삭제하고 속성에 바로 할당
  class Person constructor(name: String, age: Int) {
      var name: String = name
      var age: Int = age
  }
  ```

  ```kotlin
  // 생성자 안에 val나 var을 선언하여 보일러플레이트 코드 삭제
  class Person constructor(var name: String, var age: Int)
  ```

  ```kotlin
  // constructor 키워드 생략 가능 (생성자에 애노테이션이나 가시성 한정자가 없는 경우)
  class Person(var name: String, var age: Int)
  ```

#### 읽기 쓰기와 읽기 전용 속성

- `var`과 `val` 키워드 차이

  ```kotlin
  class Person(
      // 읽기 쓰기 속성
      var name: String, 
      // 읽기 전용 속성
      val age: Int)
  ```

  ```kotlin
  val person = Person("Eva", 25)
  
  val name = person.name
  person.name = "Kate"
  
  val age = person.age
  person.age = 28 // 에러
  ```

- 정리

  | 키워드          | 읽기   | 쓰기   |
  | --------------- | ------ | ------ |
  | `var`           | 예     | 예     |
  | `val`           | 예     | 아니오 |
  | (지원되지 않음) | 아니오 | 예     |

#### 코틀린과 자바의 속성 접근 구문

- 게터/세터 접근을 위한 `setXXX()`, `getXXX()`가 필요 없음

  ```kotlin
  class Car(var speed: Double)
  ```

  ```java
  Car car = new Car(7.4);
  car.setSpeed(9.2);
  Double speed = car.getSpeed();
  ```

  ```kotlin
  var car = Car(7.4)
  car.speed = 9.2
  val speed = car.speed
  ```

- 자바 to 코틀린, 코틀린 to 자바도 구문 사용 가능

#### 맞춤형 게터/세터

- 객체 인스턴스 생성시 속성의 부가 작업을 추가하기 위해 __맞춤형 게터/세터__를 지정할 수 있음

  ```kotlin
  class Fruit(var weight: Double) {
      var ecoRating = 3
      get() {
          println("getter value retrieved")
          return field
      }
      set(value) {
          field = if (value < 0) 0 else value
          println("setter new value assigned $field")
      }
  }
  ```

- 게터를 생략하면 __기본 값 지정 가능__

  ```kotlin
  class Fruit(var weight: Double) {
      val isHeavy = weight > 20
  }
  ```

  - `weight` 값이 변경되어도 `isHeavy` 값은 변경되지 않음

#### 지연 초기화되는 속성

- `lateinit`: 코틀린 컴파일러에게 초기화가 지연된다는 사실을 알림

  ```kotlin
  class MainActivity : AppCompatActivity() {
      private lateinit var button: Button
      
      override fun onCreate(saedInstanceState: Bundle?) {
          button = findViewById(R.id.button)
          button.text = "Click Me"
      }
  }
  ```

#### 속성과 애노테이션

- 프레임워크 애노테이션 처리기나 리플렉션 기반 라이브러리가 작동할 때 문제 발생 가능

  ```kotlin
  @Rule
  val activityRule = ActivityTestRule(MainActivity::class.java)
  ```

  - JUnit이 코틀린 속성을 이해하지 못해 제대로 초기화 되지 않음

  ```kotlin
  @JvmField
  @Rule
  val activityRule = ActivityTestRule(MainActivity::class.java)
  ```

  - `@JvmField` 애노테이션의 제약사항
    - 해당 속성에 기반 필드 존재
    - `private`이 아니어야 함
    - `open`이 없어야 함
    - `override`가 없어야 함
    - `const`가 없어야 함
    - 위임된 속성이 아니어야 함

  ```kotlin
  val activityRule
  @Rule get() = ActivityTestRule(MainActivity::class.java)
  ```

  ```kotlin
  @get:Rule
  val activityRule = ActivityTestRule(MainActivity::class.java)
  ```

  - 사용 위치 대상을 이용하면 게터에 애노테이션 추가 가능

#### 인라인 속성

- `inline`: 속성 호출의 최적화 가능

  ```kotlin
  inline val now: Long
  get() {
      println("Time retrieved")
      return System.currentTimeMillis()
  }
  ```

  - 호출 대상이 코드로 대체 됨
  - `inline`은 기반 필드가 없는 속성에만 적용 가능


### 생성자

- 주 생성자 하나와 하나 이상의 보조 생성자를 정의할 수 있음

  ```kotlin
  class Fruit(val weight: Int) {
      constructor(weight: Int, fresh: Boolean) : this(weight) { }
  }
  ```

- 생성자에 애노테이션을 적용하려 할 때

  ```kotlin
  class Fruit @Inject private constructor()
  ```

#### 속성과 생성자 매개변수의 비교

- 생성자 안의 `val`나 `var` 키워드가 빠지면 __매개변수로 인식__

  ```kotlin
  class Fruit(var weight: Double, fresh: Boolean)
  
  val fruit = Fruit(12.0, true)
  println(fruit.weight)
  println(fruit.fresh) // 에러
  ```

- 정리

  | 클래스 선언                     | 게터 생성됨 | 세터 생성됨 | 유형            |
  | ------------------------------- | ----------- | ----------- | --------------- |
  | `class Fruit(name: String)`     | 아니오      | 아니오      | 생성자 매개변수 |
  | `class Fruit(val name: String)` | 예          | 아니오      | 속성            |
  | `class Fruit(var name: String)` | 예          | 예          | 속성            |

- 속성을 사용해야 하는 경우

  - 예외를 생성하지 않음
  - 계산 비용이 적음
  - 여러 번 호출해도 같은 결과 반환

#### 기본 인수를 갖는 생성자

- 자바에서는 객체 생성시 심각한 단점이 있음 (선택적으로 필드를 초기화할 수 없음)

- 이를 해결하기 위한 __패턴이 있음__

  - __점층적 생성자 패턴__

    ```java
    View view1 = new View(context);
    View view2 = new View(context, attributeSet);
    View view3 = new View(context, attributeSet, defStyleAttr);
    ```

  - __자바빈즈 패턴__

    ```java
    Fruit fruit = new Fruit();
    fruit.setWeight(10);
    fruit.setSpeed(7.4);
    fruit.setColor("Gray");
    ```

  - __빌더 패턴__

    ```java
    Retrofit retrofit = new Retrofit.Builder()
        .baseUrl("https://api.github.com/")
        .build();
    ```

- 코틀린에서는 __기본 인수__와 __명명된 인수 구문__을 생성자에서 사용 가능

  ```kotlin
  class Fruit(weight: Int = 0, fresh: Boolean = true, color: String = "Green")
  ```

  ```kotlin
  val fruit1 = Fruit(7.4, false)
  val fruit2 = Fruit(7.4)
  val fruit3 = Fruit(weight = 7.4, fresh = true, color = "Yellow")
  val fruit4 = Fruit(color = "Yellow")
  ```


### 상속

- 코틀린의 클래스는 기본적으로 `final`임

- `open` 키워드로 열어줘야 함

  ```kotlin
  open class Plant
  class Tree : Plant()
  ```

  - `:`을 이용해 __상속 or 구현__

- 함수 또한 기본적으로 `final`임

- `open` 키워드로 열어줘야 함

  ```kotlin
  open class Plane {
      open var height = 0
      open fun grow(height: Int) {
      }
  }
  ```

  ```kotlin
  class Tree : Plant() {
      override var height = super.height
          get() = super.height
          set(value) {
              field = value
          }
      
      final override fun grow(height: Int) {
          this.height += height;
      }
  }
  ```

  - 속성도 `open`으로 열고 오버라이딩 가능
  - 오버라이딩 된 메서드는 기본적으로 `open`이기 때문에 `final`로 막을 수 있음

- 추상 클래스로 선언하고 메서드 앞에 `abstract` 키워드가 붙으면 `open`으로 열어주지 않아도 됨

#### `@JvmOverloads` 애노테이션

- `android.view.View` 클래스와 같이 점층적 생성자 패턴을 이용하는 클래스를 상속받는 경우 유용

  ```kotlin
  class KotlinView @JvmOverlads constructor(
      context: Context,
      attrs: AttributeSet? = null,
      defStyleAttr: Int = 0
  ) : View(context, attrs, defStyleAttr)
  ```

  - `@JvmOverloads` 애노테이션을 사용하면 자동으로 생성자를 오버로딩



### 인터페이스

- 자바 8 인터페이스와 유사

  ```kotlin
  interface EmailProvider {
      fun validateEmail()
  }
  ```

  ```kotlin
  class User : EmailProvider {
      override fun validateEmail() {
          ...
      }
  }
  ```

  ```kotlin
  open class Person {
      interface EmailProvider {
          fun validateEmail()
      }
      
      class User : Person(), EmailProvider {
          override fun validateEmail() {
              ...
          }
      }
  }
  ```

  - 클래스 상속과 인터페이스 구현을 동시에 해야할 경우 위와 같은 순서로 함 (권장)

  ```kotlin
  class User(override val email: String) : EmailProvider {
      override fun validateEmail() {
          ...
      }
  }
  ```

- 인터페이스와 추상 클래스의 가장 큰 차이는 __상태저장이 가능한가?__ 임



### 데이터 클래스

- 코틀린 컴파일러가 생성하는 메소드를 통해 클래스에 기능이 추가됨

  - `equals()`
  - `hashCode()`
  - `toString()`
  - `copy()`
  - 여러 componentN 함수

- `abstract`, `inner`, `sealed`를 지정할 수 없음

  ```kotlin
  data class Product(var name: String, var price: Double)
  ```

#### `equals()`와 `hashCode()` 메소드

- 자바에서 많이 쓰이는 함수들 (동등 비교와 연관)
- 필요한 경우 메소드를 재정의

#### `toString()` 메소드

- 디버깅 프로세스가 훨 씬 수월해 짐

#### `copy()` 메소드

- 코틀린 컴파일러에서 객체를 손쉽게 복사하기 위해 자동으로 생성되는 함수

- copy 생성자나 팩토리에 대한 필요성이 낮아짐

- `copy()` 함수를 이용하면 불변 객체의 내용을 수정할 수 있음 (새로운 인스턴스 생성이랑 동일하다고 보면?)

  ```kotlin
  data class Product(val name: String, val price: Double)
  
  var productA = Product("Spoon", 30.2)
  productA = productA.copy(name = "Knife")
  ```

#### 구조분해 선언

- 객체를 여러 변수로 재구성할 때 사용

  ```kotlin
  val person = Person("Igor", "Wojda", 180)
  var (firstName, _, height) = person
  
  println(firstName)
  println(height)
  ```


### 연산자 오버로딩

- 코틀린은 고정된 기호 표현에 해당하는 함수나 식이 있음

- 이 함수나 식을 오버로딩 가능함

  ```kotlin
  data class Point(var x: Double, var y: Double) {
      operator fun plus(point: Point) = Point(x + point.x, y + point.y)
      
      operator fun plus(vector: Double) = Point(x + vector, y + vector)
      
      operator fun times(other: Int) = Point(x * other, y * other)
  }
  ```

  ```kotlin
  val p1 = Point(2.9, 5.0)
  val p2 = Point(2.0, 7.5)
  
  println(p1 + p2)
  println(p1 + 3.1)
  println(p1 * 3)
  ```

  - 복합 할당 연산자가 있는 연사자를 오버로딩하면 __둘 다 지원함__

- 자바 클래스에서도 선언된 연산자 오버로딩 함수가 있으면 코틀린에서 사용 가능

  ```java
  public class Point {
      private final int x;
      private final int y;
      
      public Point(int x, int y) {
          this.x = x;
          this.y = y;
      }
      
      ...
          
      public Point plus(Point point) {
          return new Point(point.getX() + x, point.getY() + y);
      }
  }
  ```

  ```kotlin
  val p1 = Point(1, 2)
  val p2 = Point(3, 4)
  val p3 = p1 + p2
  ```


### 객체 선언

- 자바에서 싱글턴 클래스 생성은 배우 복잡 (동기화 문제)

- 코틀린에서는 __객체 선언__이라는 특수한 언어 구문으로 생성 가능

- `object` 키워드 사용

  ```kotlin
  object SQLiteSingleton {
      fun getAllUsers(): List<User> {
          ...
      }
  }
  ```

  - 정적 자바 메소드와 같은 방법으로 이용 가능

- 지연 초기화 됨

- 객체 선언 or 내부 클래스가 아닌 클래스 안에 중첩으로 들어갈 수 있음

- 변수에 할당할 수 없음



### 객체 식

- 인터페이스의 __익명 객체__를 만드는데 사용

- 어댑터 패턴과 관련된 문제를 해결할 수 있음

  ```kotlin
  interface Player {
      fun play()
  }
  
  fun playWith(player: Player) {
      println("I play with")
      player.play()
  }
  ```

  ```kotlin
  open class VideoPlayer {
      fun play() {
          println("Play video")
      }
  }
  ```

  ```kotlin
  val player = object: VideoPlayer(), Player { }
  playWith(player)
  ```



### 컴패니언 객체

- 코틀린은 정적 멤버가 없음

- __컴패니언 객체__

  - 한 번만 초기화 됨
  - 인스턴스가 하나만 있음
  - 모든 인스턴스와 객체의 상태를 공유함

  ```kotlin
  class ProductDetailsActivity : AppCompatActivity() {
      ...
      
      companion object {
          const val KEY_PRODUCT = "product"
          
          fun start(context: Context, product: Product) {
              val intent = Intent(context, ProductDefailsActivity::class.java)
              intent.putExtra(KEY_PRODUCT, product)
              context.startActivity(intent)
          }
      }
  }
  
  ViewProductActivity.start(context, productId)
  ```

#### 컴페니언 객체의 인스턴스 생성

- 



### 열거 클래스



### 명명된 메소드에 대한 중위 호출



### 가시성 한정자

#### `internal` 한정자와 자바 바이트 코드



### 봉인 클래스



### 중첩 클래스



### 별칭 포인트

