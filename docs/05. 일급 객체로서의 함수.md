## 05. 일급 객체로서의 함수

### 함수 형식

- 코틀린 함수는 __일급 객체__

- __일급 객체__: 다른 엔티티에 허용되는 모든 작업이 허용되는 엔티티

  > 작업: __인수로서 전달, 함수에서 반환, 변수에 할당__이 포함

- 함수 형식 정의

  > (매개변수 형식0) -> 반환 형식

  ```kotlin
  lateinit var a: (Int) -> Int
  lateinit var b: () -> Int
  lateinit var c: (String) -> Unit
  ```

> ####  함수 형식의 의미
> - 함수를 할당할 수 있는 변수나 매개변수 형식
> - 함수를 받거나 반환하는 상위 함수의 인수나 반환 형식
> - __코틀린에서는 인터페이스__로 취급

#### 함수 형식의 내부 작동 방식

- 함수 형식은 __제네릭 인터페이스를 나타내는 일종의 편의 문법__

  - `() -> Unit` 시그니처는 `Function0<Unit>` 인터페이스를 나타냄
    - `Function0` 식은 매개변수가 없음
    - `Unit`은 반환 형식
  - `(Int) -> Unit` 시그니처는 `Function1<Int, Unit>` 인터페이스를 나타냄
    - `Function1` 식은 매개변수가 하나
  - `() -> (Int, Int) -> String` 시그니처는 `Function0<Function2<Int, Int, String>>` 인터페이스를 나타냄

- 모든 인터페이스는 연산자인 `invoke` 메소드를 하나 가지며, 객체를 함수처럼 사용할 수 있음

  ```kotlin
  val a: (Int) -> Unit = // ...
  a(10)
  a.invoke(10)
  ```



### 익명 함수

- 함수를 객체로 정의하는 방법 중 하나

- 일반 함수와 같은 방법으로 작동

- `fun` 키워드와 매개변수 선언 사이에 이름이 없음

- __기본적으로 객체__로 취급

  ```kotlin
  val a = fun(i: Int) = i * 2 // (Int) -> Int
  val b = fun(): Int { return 4 } // () - >Int
  val c = fun(s: String) { println(s) } // (String) -> Unit
  ```

- 내부에  `invoke` 메소드만 있음



### 람다식

- 가장 간단히 익명 함수를 정의하는 방법

- 람다식 표기법

  > { 인수 -> 함수 본체 }

  ```kotlin
  var a = { i: Int -> i * 2 } // (Int) -> Int
  var b = { 4 } // () -> Int
  var c = { s: String -> println(s) } // (String) -> Unit
  ```

- __논로컬__  `return`은 허용되지 않음

  ```kotlin
  var a = { i: Int -> return i * 2 } // (Int) -> Int
  var l = l@ { i: Int -> return@l i * 2 } // (Int) -> Int
  ```

- 여러행 표기

  ```kotlin
  val printAndReturn { i: Int, j: Int -> 
  	println("I calculate $i + $j")
  	i + j // return
  }
  ```

- 여러 개의 문을 한 행에 정의 할 때는 `;`으로 문을 분리

- 코틀린 람다식은 생성된 __컨텍스트에서 접근 가능한 모든 속성과 함수 사용 가능__

- __클로저__: 로컬 변수를 감싸며 함수 본체 안에서 변경할 수 있게 해주는 람다식

  > 클로저 == 람다 

#### 단일 매개변수의 암시적 이름

- `it` 키워드 사용 조건

  - 매개변수 하나
  - 매겨변수 형식을 컨텍스트로부터 유추 가능

  ```kotlin
  val a = { it * 2 } // (Int) -> Int
  val c = { println(it) } // (String) -> Unit
  ```

- 이 표기법은 매개변수 형식을 지정할 필요 없음

- LINQ 스타일로 정의된 작업의 가독성을 높임

  > LINQ 스타일: https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/linq/introduction-to-linq-queries

  ```kotlin
  strings.filter { it.lenght = 5 }.map { it.toUpperCase() }
  ```



### 고차 함수

- __고차 함수__: 함수를 인수로 받고 그 결과로 다른 함수를 반환하는 함수

  ```kotlin
  fun sum(numbers: List<BigDecimal>) = fold(numbers, BigDecimal.ZERO) { 
      acc, num -> acc + num
  }
  ...
  
  private fun fold(numbers: List<BigDecimal>,
                   start: BigDecimal,
                   accumulator: (BigDecimal, BigDecimal) -> Bigdecimal): BigDecimal {
      var acc = start
      for (num in numbers) {
          acc = accumulator(acc, num)
      }
      
      return acc
  }
  ...
  ```

- 함수를 인수로 전달하는 가장 일반적인 세가지 사용 사례

  1. 함수를 작업으로서 제공
  2. Observer 패턴
  3. 스레드 작업 후 콜백

#### 함수를 작업으로서 제공

- p.240 참고

#### Observer 패턴

- p.241 참고

#### 스레드 작업 후 콜백

- p.242 참고



### 명명된 인수와 람다식의 조합

- 명명된 인수와 람다식은 안드로이드 환경에서 아주 유용
- p.243 ~ p.244 참고



### 마지막 람다식 인수 규칙

- 고차 함수는 __아주 중요__하므로 __최대한 편리하게 사용할 수 있게__ 하는 것이 중요

- __매개변수 마지막에 함수 형식인 경우, 괄호 바깥에 람다식을 정의할 수 있음__

  ```kotlin
  fun longOperationAsync(a: Int, callback: () -> Unit) {
      // ...
  }
  ```

#### 주변 코드 명명

- 코드의 일부를 다른 방식으로 실행하도록 표시해야 하는 경우 사용

   ```kotlin
     fun isSupportsLolipop(f: () -> Unit) {
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLIPOP) {
          f()
      }
     }
   ```

  // 사용법
  ifSupportsLolipop {
​      // 작업
  }
   ```

#### LINQ 스타일로 데이터 구조 처리

- 마지막 람다식 인수 규칙은 가독성을 한 차원 높여줌

  ```kotlin
  strings.filter { it.lenght == 5 }.map { it.toUpperCase() }
   ```



### 코틀린의 자바 SAM 지원

- __SAM__: Single Abstract Method or 함수형 인터페이스
- p.249 ~ p.252 참고



### 명명된 코틀린 함수 형식

- 가독성을 높이기 위한 방법

#### 함수 혐식의 명명된 매개변수

- 예제

  ```kotlin
  fun setOnItemClickListener(listener: (Int, View, View) -> Unit) // IDE에서 도움 받지 못함
  fun setOnItemClickListener((position: Int, view: View, parent: View) -> Unit) // LGTM
  ```

#### 형식 별칭

- 코틀린 1.1부터 사용 가능

  ```kotlin
  data class User(val name: String, val surname: String)
  typealias Users = List<User>
  ```

- 가독성을 높이기 위해 사용하는 것
- 원래 형식도 함께 사용 가능
- p.254 ~ p.257 참고



### 사용되지 않는 변수를 위한 밑줄

- IDE에서 제공



### 람다식의 구조분해

- 코틀린 1.1부터 람다 매개변수에 구조분해 선언 구문 이용 가능

  ```kotlin
  val showUser: (User) -> Unit = { (name, surname, phone) -> 
      // ...
  }
  ```

- p.258 ~ p.261 참고



### 인라인 함수

- 고차 함수는 아주 유용하며 코드의 재사용성을 크게 개선 가능
- 하지만, 효율에 대해서는 우려가 있음 (자바 객체 생성과 관련)
- 인라인으로 표시하면 __컴파일러가 코드 컴파일 중에 해당 함수 호출을 함수 본체의 코드로 대체__

#### 부작용

1. 바이트 코드가 길어짐
2. 재귀할 수 없으며, 현재 람다식보다 엄격한 가시성 한정자를 가진 함수나 클래스 사용 불가
3. 람다식이 생성되지 않았을 때는 함수 형식인 매개변수를 다른 함수로 전달할 수 없음

#### 주의사항

- 인라인 함수는 작은 함수에 사용해야 함
- API를 보고하기 위해 최대한 많은 부분을 `private`으로 만들어야 하는 라이브러리에서는 문제 발생 가능

#### `noinline` 한정자

- 부작용 3번을 해결할 수 있는 방법

  ```kotlin
  fun boo(f: () -> Unit) {
      // ...
  }
  
  inline fun foo(before: () -> Unit, noinline f: () -> Unit) {
      before()
      boo(f)
  }
  ```

- 모든 매개변수를 `noinline`으로 만들면 인라인 성능 향상은 거의 상쇄

#### 논로컬 반환

- 일반적인 `return` 문

  ```kotlin
  fun maxBounded(list: List<Int>, upperBound: Int, lowerBound: Int): Int {
      var currentMax = lowerBound
      forEach(list) { i ->
          when {
              i > upperBound -> return upperBound // 오류: 논로컬 반환
              i > currentMax -> currentMax = i
          }
      }
      
      return currentMax
  }
  ```

#### 람다식의 라벨 반환
- 람다식의 라벨을 붙이거나 __암시적 라벨__을 이용해 반환가능
- p.269 ~ p.273 참고

#### `crossinline` 한정자

- 논로컬 반환을 금지하도록 컴파일러에게 알림

  ```kotlin
  fun boo(f: () -> Unit) {
      // ...
  }
  
  inline fun foo(crossinline f: () -> Unit) {
      boo { println("A"); f() }
  }
  
  fun main(args: Array<String>) {
      foo { println("B") }
  }
  ```

#### 인라인 속성

- 코틀린 1.1 이상에서는 기발 필드가 없는 속성에 `inline` 한정자를 지정할 수 있음

  ```kotlin
  var viewIsVisible: Boolean
  inline get() = findViewById(R.id.view).visibility == View.VISIBLE
  inline set(value) {
      findViewById(R.id.view).visibility = if (value) View.VISIBLE else View.GONE
  }
  ```

- p.275 ~ p.276 참고



### 함수 참조

- 인수로 전달하려는 함수가 이미 별도의 함수로 정의된 경우, 간단하게 호출 가능

  ```kotlin
  fun isOdd(i: Int) = i % 2== 1
  
  list.filter(::isOdd)
  ```

- __바인딩 참조__: 코틀린 1.1에서 특정 객체에 바인딩되는 참조를 제공하기 위한 기능

- p.276 ~ p.280 참고
