## 코틀린에서 컬렉션 만들기

- 코틀린은 자체 컬렉션을 지원하지 않음
  ___Why?___
  - __자바 코드와 상호작용__하기 __쉽게__하기 위해
  - 서로 __변환할 일도 없음__
- 하지만, 자바 컬렉션보다 __훨씬 많은 기능을 제공__

## 함수를 호출하기 쉽게 만들기

```kotlin
val list = listOf(1, 2, 3)
println(list)

--- 결과 ---
[1, 2, 3]
```

- 기본적으로 `toString` 구현이 포함
- 다른 형식으로 바꾸려면?

```kotlin
fun <T> joinToString(
    collection: Collection<T>, 
    separator: String, 
    prefix: String, 
    postfix: String
) : String { ... }
```

- 위와 같은 함수를 만들고
- 아래와 같이 사용

```kotlin
val list = listOf(1, 2, 3)
println(joinToString(list, "; ", "(", ")"))

--- 결과 ---
(1; 2; 3;)
```

- 잘 작동하고 그대로 써도 되지만 튜닝 가능함

### 이름 붙인 인자

```kotlin
joinToString(collection, " ", " ", ".")
```

- 어느게 구분자이고 어느게 처음과 끝에 붙는 문자일까?
- 자바에서도 이와 비슷한 문제가 있음 > __대표적으로__ `boolean` __파라미터__
- 자바에서는 위와 같은 문제를 해결하기 위해 `enum` 이나 __주석__을 사용하도록 함
- 코틀린에서는 __인자에 이름을 붙일 수 있음__

```kotlin
joinToString(collection, separator = " ", prefix = " ", postfix = ".")
```

- __이름이 명시된 인자 뒤의 인자들도 반드시 이름이 명시되어야 함__

### 디폴트 파라미터 값

- 자바에서는 __메소드 오버로딩__으로 인해 한 클래스에 메소드가 너무 많아짐
- 코틀린에서는 __디폴트 파라미터 값__을 지정해 불필요한 메소드 오버로딩을 줄 일 수 있음

```kotlin
fun <T> joinToString(
    collection: Collection<T>,
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
) : String { ... }
```

- 아래와 같이 호출 가능

```kotlin
joinToString(list, ", ", "", "")
joinToString(list)
joinToString(list, ";")
```

- 인자에 이름을 명시하면 인자 순서와 관계없이 호출가능

```kotlin
joinToString(list, postifx = ";", prefix = "# ")

--- 결과 ---
# 1, 2, 3;
```

- 참고

> #### 디폴트 값과 자바
>
> 자바는 디폴트 파라미터 값 개념이 없음
>
> 자바에서 디폴트 파라미터 값이 적용된 코틀린 함수를 호출할 때는 문제
> (모든 파라미터에 값을 넣어줘야 함)
>
> 이 때, `@JvmOverloads` 어노테이션을 붙이면 __코틀린 컴파일러__가 자동으로 오버로딩된 메서드를 만듦

### 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티

#### 최상위 함수

- 자바에서는 클래스 아래에 메서드가 선언되어야 하므로
  유틸리티 메서드만 있는 상황에서 불필요한 클래스가 선언되어야 함
- 코틀린은 이를 해결하기 위해 __파일 최상위 수준에서 함수 선언 가능__

```kotlin
package strings

fun joinToString(...) : String { ... }
```

- 해당 최상위 함수를 자바에서 쓸 때는 컴파일러가 클래스를 만들어 줌

> #### 파일에 대응하는 클래스의 이름 변경하기
>
> `@JvmName` 어노테이션을 추가하면 클래스 이름을 지정, 변경할 수 있음
>
> ```kotlin
> @file:JvmName("StringFunctions")
> 
> package strings
> 
> fin joinToString(...) : String { ... }
> ```
>
> ```java
> import strings.StringFunctions;
> 
> StringFunctions.joinToString(list, ", ", "", "");
> ```

#### 최상위 프로퍼티

- 최상위 함수와 동일
- 최상위 프로퍼티를 이용해 코드에 상수 추가 가능

```kotlin
val UNIX_LINE_SEPARATOR = "\n"
```

- 다른 모든 프로퍼티와 동일하게 접근자 메서드를 가지며 자바 코드에 노출됨
- 더 자연스럽게 사용하려면 `public static final` 필드로 컴파일되게 해야 함
- 코틀린에서는 `const` 키워드 사용

```kotlin
const val UNIX_LINE_SEPARATOR = "\n"
```

- `const` 키워드는 원시 타입과 `String`에서만 사용 가능

## 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

- __확장 함수__: 기존 자바 API 재작성 없이 편리한 기능을 제공해주는 방법

```kotlin
package strings

fun String.lastChar() : Char = this.get(this.length - 1)
    -> 수신 객체 타입             -> 수신 객체 <-
```

```kotlin
println("Kotlin".lastChar())
```

- 확장 함수도 `this` 키워드 생략 가능

```kotlin
package strings

fun String.lastChar() : Char = get(length - 1)
```

- 확장 함수는 __캡슐화를 깨지 않음__
  - `private`, `protected` 접근 제한이 걸린 멤버를 사용할 수 없음
- __메소드__: 클래스의 멤버 메소드와 확장 함수를 일컫는 용어

### 임포트와 확장 함수

- 확장 함수를 어디서든 쓸 수 있다면, 한 클래스 안에서 이름이 충돌하는 경우가 자주 있음
- 그래서 임포트하여 씀

```kotlin
import strings.lastChar

val c = "Kotlin".lastChar()
```

```kotlin
import strings.*

val c = "Kotlin".lastChar()
```

```kotlin
import strings.lastChar as last

val c = "Kotlin".last()
```

- `as` 키워드로 임포트한 클래스나 함수를 다른 이름으로 부를 수 있음
  즉, 이름으로 인한 충돌 해결 가능

### 자바에서 확장 함수 호출

```java
char c = StringUtilKt.lastChar("Java");
```

- 수신 객체는 인자로 전달

### 확장 함수로 유틸리티 함수 정의

```kotlin
fun <T> Collection<T>.joinToString(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
) : String { ... }
```

```kotlin
val list = listOf(1, 2, 3)
println(list.joinToString(separator = "; ", prefix = "(", postfix = ")"))
```

- 확장 함수는 __정적 메서드 호출에 대한 문법적인 편의일 뿐__
- 더 구체적인 타입으로 수신 객체 타입 지정 가능

```kotlin
fun Collection<String>.join(
    separator: String = ", ",
    prefix = "",
    postfix = ""
) = joinToString(separator, prefix, postfix)
```

### 확장 함수는 오버라이드할 수 없다

- 멤버 함수 오버라이딩은 __동적 디스패치__
- 확장 함수는 __정적 디스패치__
  즉, 컴파일 타임에 수신 객체 타입에 의해 결정됨

```kotlin
fun View.showOff() = println("I`m a view!")
fun Button.showOff() = println("I`m a button!")

val view: View = Button();
view.showOff()

--- 결과 ---
I`m a view!
```

- 자바에서도 같은 방식으로 결정

```java
View view = new Button();
ExtensionsKt.showOff(view);

--- 결과 ---
I`m a view!
```

> #### 확장 함수와 멤버 함수의 우선순위
>
> 어떤 클래스에 확장 함수와 멤버 함수의 __이름__과 __시그니쳐__가 __같다면__ __멤버 함수__가 __호출__

### 확장 프로퍼티

- 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수 있는 API 추가 가능
- 하지만, 상태를 저장하지 못함
  (기존 클래스의 인스턴스 객체를 주입할 수 있는 방법 X)
- 프로퍼티 문법으로 더 짧게 코드를 작성할 수 있음

```kotlin
val String.lastChar: Char
    get() = get(length - 1)
```

```kotlin
val StringBuilder.lastChar: Char
    get() = get(length - 1)
    set(value: Char) {
        this.setCharAt(length - 1, value)
    }
```

- 사용법은 멤버 프로퍼티와 동일

```kotlin
println("Koltin".lastChar)
```

- 자바

```java
StringUtilKt.getLastChar("Java")
```

## 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

- `vararg` 키워드는 __가변 인자__
- __중위 함수 호출 구문__은 인자가 하나 뿐인 메소드를 간편하게 호출
- __구조 분해 선언__은 복합적인 값을 분해해 여러 변수에 나눠 담을 수 있음

### 자바 컬렉션 API 확장

- 앞서 보았던 `last()`와 `max()` 함수는 __확장 함수__

```kotlin
fun <T> List<T>.last() : T { ... }
fun Collection<Int>.max() : Int { ... }
```

### 가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의

- 자바의 가변 길이 인자와 동일

- 다만 키워드와 특정 사용법이 다름

```kotlin
fun listOf<T>(vararg values: T) : List<T> { ... }
```

- 위는 `listOf()` 함수의 정의

```kotlin
fun main(args: Array<String>) {
    val list = listOf("args: ", *args)
    println(list)
}
```

- 배열을 가변 인자로 넘길 때 __스프레드 연산자__를 사용

### 값의 쌍 다루기: 중위 호출과 구조 분해 선언

- 맵을 만들 때, 아래와 같은 `to` 키워드를 볼 수 있음

```kotlin
val map = mapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
```

- 하지만, `to`는 키워드가 아니라 __함수__
- __중위 호출__이라는 특별한 방식으로 `to()` 메소드를 호출 한 것
- 중위 호출 시에는 __수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣음__

```kotlin
1.to("one")
1 to "one"
```

- 위 두 호출은 동일
- __인자가 하나뿐인__ 메소드는 중위 호출을 허용할 수 있음
- 중위 호출 허용은 `infix` __변경자__를 함수 선언 앞에 추가

```kotlin
infix fun Any.to(other: Any) = Pair(this, other)
```

- 사실 `to()` 함수는 제네릭 함수지만 알고만 있자.

```kotlin
val (number, name) = 1 to "one"
```

- 위와 같이 `Pair` 변수를 초기화할 수도 있는데, 이를 __구조 분해 선언__이라고 함
- 동작하는 부분은 p.128 참고
- `Pair` 외에도 key, value 쌍인 멤버 변수도 사용 가능
- 루프에서도 사용 가능

```kotlin
for((index, element) in collection.withIndex()) {
    println("$index: $element")
}
```

- `in`은 __연산자__
- [범위와 관련된 재미난 것](https://kotlinlang.org/docs/reference/ranges.html)

### 문자열과 정규식 다루기

- 정규식은 강력하나 나중에 코드를 알아보기 힘듦
  정규식을 사용해야 하는 상황이면 코틀린 라이브러리를 사용하길 추천

> #### 라이브러리 알선(Pimp My Library) 패턴
>
> 기존 라이브러리를 새 언어에서 활용하는 패턴
>
> __코틀린 표준 라이브러리__와 __Anko 라이브러리__도 이에 해당

- 예제기 때문에 추가적으로 정리하지 않으며 책 참고

### 코드 다듬기: 로컬 함수와 확장

- 개발자들은 __DRY__를 피하기 위해 많은 노력을 함
- __메소드 추출 리팩토링__을 하면 __자칫 메소드 수가 많아 질 수 있음__
- 추출된 메소드를 __별도의 내부 클래스로 넣게__되면 __준비 코드가 늘어남__
- 코틀린에서는 이를 __로컬 함수__를 통해 중복을 줄일 수 있게 해줌

```kotlin
fun saveUser(user: User) {
    if (user.name.isEmpty()) {
        throw IllegalArgumentException("Can't save user ${user.id}: empty Name")
    }
    
    if (user.address.isEmpty()) {
        throw IllegalArgumentException("Can't save user ${user.id}: empty Address")
    }
    
    // user를 데이터베이스에 저장
}
```

- 그렇게 큰 중복은 아니지만, 로컬 함수를 이용해 줄일 수 있음