## 코틀린에서 컬렉션 만들기

- 코틀린은 자체 컬렉션을 지원하지 않음
  ___Why?___
  - __자바 코드와 상호작용__하기 __쉽게__하기 위해
  - 서로 __변환할 일도 없음__
- 하지만, 자바 컬렉션보다 __훨씬 많은 기능을 제공__

## 함수를 호출하기 쉽게 만들기

```kotlin
val list = listOf(1, 2, 3)
println(list)

--- 결과 ---
[1, 2, 3]
```

- 기본적으로 `toString` 구현이 포함
- 다른 형식으로 바꾸려면?

```kotlin
fun <T> joinToString(
    collection: Collection<T>, 
    separator: String, 
    prefix: String, 
    postfix: String
) : String {
    ...
} 
```

- 위와 같은 함수를 만들고
- 아래와 같이 사용

```kotlin
val list = listOf(1, 2, 3)
println(joinToString(list, "; ", "(", ")")

--- 결과 ---
(1; 2; 3;)
```

- 잘 작동하고 그대로 써도 되지만 튜닝 가능함

### 이름 붙인 인자

```kotlin
joinToString(collection, " ", " ", ".")
```

- 어느게 구분자이고 어느게 처음과 끝에 붙는 문자일까?
- 자바에서도 이와 비슷한 문제가 있음 > __대표적으로__ `boolean` __파라미터__
- 자바에서는 위와 같은 문제를 해결하기 위해 `enum` 이나 __주석__을 사용하도록 함
- 코틀린에서는 __인자에 이름을 붙일 수 있음__

```kotlin
joinToString(collection, separator = " ", prefix = " ", postfix = ".")
```

- __이름이 명시된 인자 뒤의 인자들도 반드시 이름이 명시되어야 함__

### 디폴트 파라미터 값

- 자바에서는 __메소드 오버로딩__으로 인해 한 클래스에 메소드가 너무 많아짐
- 코틀린에서는 __디폴트 파라미터 값__을 지정해 불필요한 메소드 오버로딩을 줄 일 수 있음

```kotlin
fun <T> joinToString(
    collection: Collection<T>,
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
) : String {
    ...
}
```

- 아래와 같이 호출 가능

```kotlin
joinToString(list, ", ", "", "")
joinToString(list)
joinToString(list, ";")
```

- 인자에 이름을 명시하면 인자 순서와 관계없이 호출가능

```kotlin
joinToString(list, postifx = ";", prefix = "# ")

--- 결과 ---
# 1, 2, 3;
```

- 참고

> ####디폴트 값과 자바
>
> 자바는 디폴트 파라미터 값 개념이 없음
>
> 자바에서 디폴트 파라미터 값이 적용된 코틀린 함수를 호출할 때는 문제
> (모든 파라미터에 값을 넣어줘야 함)
>
> 이 때, `@JvmOverloads` 어노테이션을 붙이면 __코틀린 컴파일러__가 자동으로 오버로딩된 메서드를 만듦

### 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티

#### 최상위 함수

- 자바에서는 클래스 아래에 메서드가 선언되어야 하므로
  유틸리티 메서드만 있는 상황에서 불필요한 클래스가 선언되어야 함
- 코틀린은 이를 해결하기 위해 __파일 최상위 수준에서 함수 선언 가능__

```kotlin
package strings

fun joinToString(...) : String {
    ...
}
```

- 해당 최상위 함수를 자바에서 쓸 때는 컴파일러가 클래스를 만들어 줌

> #### 파일에 대응하는 클래스의 이름 변경하기
>
> `@JvmName` 어노테이션을 추가하면 클래스 이름을 지정, 변경할 수 있음
>
> ```kotlin
> @file:JvmName("StringFunctions")
> 
> package strings
> 
> fin joinToString(...) : String {
>     ...
> }
> ```
>
> ```java
> import strings.StringFunctions;
> 
> StringFunctions.joinToString(list, ", ", "", "");
> ```

#### 최상위 프로퍼티

- 최상위 함수와 동일
- 최상위 프로퍼티를 이용해 코드에 상수 추가 가능

```kotlin
val UNIX_LINE_SEPARATOR = "\n"
```

- 다른 모든 프로퍼티와 동일하게 접근자 메서드를 가지며 자바 코드에 노출됨
- 더 자연스럽게 사용하려면 `public static final` 필드로 컴파일되게 해야 함
- 코틀린에서는 `const` 키워드 사용

```kotlin
const val UNIX_LINE_SEPARATOR = "\n"
```

- `const` 키워드는 원시 타입과 `String`에서만 사용 가능

## 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

- __확장 함수__: 기존 자바 API 재작성 없이 편리한 기능을 제공해주는 방법

```kotlin
package strings

fun String.lastChar() : Char = this.get(this.length - 1)
    -> 수신 객체 타입             -> 수신 객체 <-
```

```kotlin
println("Kotlin".lastChar())
```

- 확장 함수도 `this` 키워드 생략 가능

```kotlin
package strings

fun String.lastChar() : Char = get(length - 1)
```

- 확장 함수는 __캡슐화를 깨지 않음__
  - `private`, `protected` 접근 제한이 걸린 멤버를 사용할 수 없음
- __메소드__: 클래새의 멤버 메소드와 확장 함수를 일컫는 용어

### 임포트와 확장 함수

- 확장 함수를 어디서든 쓸 수 있다면, 한 클래스 안에서 이름이 충돌하는 경우가 자주 있음
- 그래서 임포트하여 씀

```kotlin
import strings.lastChar

val c = "Kotlin".lastChar()
```

```kotlin
import strings.*

val c = "Kotlin".lastChar()
```

```kotlin
import strings.lastChar as last

val c = "Kotlin".last()
```

- `as` 키워드로 임포트한 클래스나 함수를 다른 이름으로 부를 수 있음
  즉, 이름으로 인한 충돌 해결 가능

### 자바에서 확장 함수 호출

```java
char c = StringUtilKt.lastChar("Java");
```

- 수신 객체는 인자로 전달

### 확장 함수로 유틸리티 함수 정의

```kotlin
fun <T> Collection<T>.joinToString(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
) : String {
    ...
}
```

```kotlin
val list = listOf(1, 2, 3)
println(list.joinToString(separator = "; ", prefix = "(", postfix = ")"))
```

- 확장 함수는 __정적 메서드 호출에 대한 문법적인 편의일 뿐__
- 더 구체적인 타입으로 수신 객체 타입 지정 가능

```kotlin
fun Collection<String>.join(
    separator: String = ", ",
    prefix = "",
    postfix = ""
) = joinToString(separator, prefix, postfix)
```

### 확장 함수는 오버라이드할 수 없다

- 멤버 함수 오버라이딩은 __동적 디스패치__
- 확장 함수는 __정적 디스패치__
  즉, 컴파일 타임에 수신 객체 타입에 의해 결정됨

```kotlin
fun View.showOff() = println("I`m a view!")
fun Button.showOff() = println("I`m a button!")

val view: View = Button();
view.showOff()

--- 결과 ---
I`m a view!
```

- 자바에서도 같은 방식으로 결정

```java
View view = new Button();
ExtensionsKt.showOff(view);

--- 결과 ---
I`m a view!
```

