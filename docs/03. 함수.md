## 03. 함수

### 기본적인 함수 선언과 사용법
- 선언

  ```kotlin
  fun double(i: Int): Int {
      return 2 * i
  }
  ```

#### 매개변수

- __파스칼 표기법__ 사용
- 형식을 __명시적으로 지정__해야 함
- __읽기 전용 변수__로 정의됨
- __가변__으로 만들 수 __없음__
- `Any`나 `Any?` 형식으로도 선언 가능

#### 함수에서 반환

- 코틀린은 __프로시저가 없음__

- 반환 값이 없는 경우 `Unit`을 반환

  > `Unit`은 __싱글톤__이므로 하나의 인스턴스만 존재
  > 아래 세 조건은 모두 `true`
  >
  > ```kotlin
  > println(p is Unit)
  > println(p == Unit)
  > println(p === Unit)
  > ```

- 나머지 내용은 __자바와 동일__



### `vararg` 매개변수

> 자바 가변인자의 대안으로 생각됨

- 매개변수의 수를 모를때 사용

  ```kotlin
  fun printAll(vararg texts: String) {
      val allTexts = texs.joinToString(",")
      println("Texts are $allTexts")
  }
  ```

- `vararg` 매개변수는 한 __함수에 하나만 허용__

- `*` 연산자를 이용해 값의 배열을 전달할 수 있음

  ```kotlin
  val texts = arrayOf("B", "C", "D")
  printAll(*texts)
  ```



### 단일 식 함수

- 단일 식을 반환하는 케이스들

  - 소규모 작업의 분리
  - 다형성을 이용해 특정 클래스에 값 제공
  - 객체를 생성
  - 아키텍처 레이어 간에 데이터 전달 (ex. MVP 패턴)
  - 되풀이에 기반을 둔 함수형 프로그래밍 스타일의 함수

- 코틀린에서는 이를 위해 __단일 식__ 표기법 제공

  ```kotlin
  fun square(x: Int) = x * x
  ```

- 특히, 안드로이드에서 유용하게 사용 가능

  ```kotlin
  class AddressAdapter : ItemAdapter<AddressAdapter.ViewHolder>() {
      override fun getLayoutId() = R.layout.choose_address_view
      override fun onCreateViewHolder(itemView: View) = ViewHolder(itemView)
      ...
  }
  ```

- `when` 식과도 조합할 수 있음 (자세한 예제는 p.122 참고)

- 단일 식은 __코드를 훨씬 간결하고 읽기 쉽게 만듦__



### 꼬리 재귀 함수

- 재귀 함수

  - 자기 자신을 호출하는 함수
  - 호출 주소를 스택에 저장
  - __StackOverFlow__ 에러가 발생 가능

- 꼬리 재귀 함수

  - 최신 언어에서 지원
  - 재귀 함수의 문제점을 해결
  - `tailrec` 수정자 이용

  ```kotlin
  tailrec fun getstate(state: State, n: Int): State = 
      if (n <= 0) state
      else getState(state.nextState(), n - 1)
  ```

- 왜 __StackOverFlow__ 문제를 벗어날 수 있을까?

  > 자바로 디컴파일된 코드를 보자

  ```java
  public static final State getState(@NotNull State state, int n) {
      while (true) {
          if (n <= 0) {
              return state;
          }
          
          state = state.nextState();
          n = n - 1;
      }
  }
  ```

- 꼬리 재귀 함수를 __사용할 수 있는 조건__
  - 수행하는 마지막 작업으로 __자기 자신을 호출__
  - `try-catch-finally` 블록 안에서 사용 불가
  - JVM으로 컴파일되는 코틀린에서만 허용

![tailrec](/Users/bladek/Naver/bladek/images/tailrec.png)



### 함수를 호출하는 다른 방법

- 인수를 일부만 전달하면서 함수를 호출하고 싶을 때가 있음

- 자바는 `null` 값을 명시적으로 전달

  ```java
  printValue("abc", null, null, "!");
  ```

  - 혹은 메서드 오버로딩을 통해 해결해야 함

- 코틀린은 위 문제들을 해결하기 위해, __기본 인수__와 __명명된 인수 구문__을 지원

#### 기본 인수 값

- C++의 그것과 동일

  ```kotlin
  fun printValue(value: String, inBracket: Boolean = true, prefix: String = "", suffix: String = "") {
      ...
  }
  ```

#### 명명된 인수 구문

- 인수 이름을 이용해 특정 인수를 전달 가능

  ```kotlin
  printValue("str", suffix = "!")
  ```

- 명명된 인수 구문이 나오면 __다음 인수부터 명명된 인수로 적용해야 함__

  ```kotlin
  printValue("str", true, "")
  printValue("str", true, prefix = "")
  printValue("str", inBracket = true, prefix = "")
  printValue("str", inBracket = true, "") // 오류
  printValue("str", inBracket = true, prefix = "", "") // 오류
  ```

- 주의 사항

  - 매개 변수이름 변경시 오류 발생할 수 있음 (리팩토링 툴 사용, 프로젝트 제한적)

    > 코틀린 라이브러리 개발자들은 이를 주의

  - 자바 함수는 코틀린에서 __명명된 인수 구문 사용 불가__



### 최상위 함수

- 코틀린은 다양한 엔티티를 최상위에 정의 할 수 있음

- 함수의 경우 __최상위 함수__

  ```kotlin
  // Test.kt
  package com.example
  
  fun printTwo() {
      print(2)
  }
  ```

  - 가시성 한정자가 `public`인 경우 어디서든 사용 가능

- 최상위 함수의 경우 __모든 컨텍스트에 제시되기 때문에 네이밍에 주의를 기해야 함__

  - 적절한 이름
    - `factorial`
    - `maxOf` 혹은 `minOf`
    - `listOf`
    - `println`
  - 적절치 못한 이름
    - `sendUserData`
    - `showPossiblePlayers`



### 최상위 함수의 내부 작동 방식

- 최상위 함수는 자바에서 이렇게 변환됨

  ```kotlin
  // Printer.Kt
  fun printTwo() {
      print(2)
  }
  ```

  ```java
  public static final PrinterKt {
      public static void printTwo() {
          System.out.println(2);
      }
  }
  ```

- `JvmName` 어노테이션

  ```kotlin
  @file:JvmName("Printer")
  ```

  - JVM이 생성하는 클래스 이름 변경

- `JvmMultifileClass`

  ```kotlin
  @file:JvmMultifileClass
  ```

  - JVM 컴파일 시, 동일한 클래스에 포함



### 로컬 함수

- 함수 내부의 함수 정의

  ```kotlin
  fun loadUsers(ids: List<Int>) {
      var download: List<User> = emptyList()
      
      fun printLog(comment: String) {
          Log.i("loadUsers (with ids $ids): $comment\nDownload: &download")
      }
      
      for (id in ids) {
          printLog("Start downloading for id $id")
          downloaded += loadUser(id)
          printLog("Finished downloading for id $id")
      }
  }
  ```

  - 바깥 쪽 함수의 로컬 변수까지 접근 가능



### `Nothing` 반환 형식

- 항상 예외를 생성하는 함수를 정의해야 하는 경우 사용

- 사용처

  - 라이브러리 단 함수 (오류 생성 간소화)
  - 단위 테스트 (오류를 생성하고 코드에서 처리할 때)

- 항상 예외를 반환

  ```kotlin
  fun fail(): Nothing = throw Error()
  ```

  - `return` 구문 불필요

- __비어있는 형식__

  ```kotlin
  fun getFirstCharOrFail(str: String): Char =
      if (str.isNotEmpty()) str[0] else fail()
  
  val name: String = getName() ?: fail()
  ```

  - `Nothing`은 모든 클래스의 하위 형식이자 형식이 없는 __비어있는 형식__

