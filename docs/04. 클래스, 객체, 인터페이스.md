## 클래스 계층 정의

- 코틀린은 자바와 달리 기본 가시성/접근자가 다름
- 새로 도입된 `sealed` 변경자?
  ___간단히 말해 상속을 제한___

### 코틀린 인터페이스

- 자바 8과 비슷
  - 추상 메소드 or 구현이 있는 메소드 정의 가능
  - 코틀린에서는 __아무런 필드를 정의할 수 없음__

```kotlin
interface Clickable {
    fun click()
}
```

```kotlin
class Button : Clickable {
    override fun click() = println("I was clicked")
}
```

- 코틀린에서 상속은 `:`을 붙임
- 상속과 구현의 제한은 자바와 동일
- 코틀린에서는 `override` __변경자__를  반드시 사용해야 함 (컴파일 실패)
  _자바의_ `@Override`_는 생략 가능_

```kotlin
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable!")
}
```

- 코틀린에서 구현이 있는 메소드 정의는 자바의 `default` 키워드처럼 별다른 키워드가 필요없음

```kotlin
interface Clickable {
    ...
    fun showOff() = println("I'm clickable!")
}
```

```kotlin
interface Focusable {
    ...
    fun showOff() = pritnln("I'm focusable!")
}
```

- 위 두 인터페이스를 상속받는 하나의 클래스에서 `showOff()` 함수는 어떻게 동작할까?

  ___어느 쪽도 선택되지 않으며, 컴파일 에러 발생___

```kotlin
class Button : Clickable, Focusable {
    ...
    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

- 위와 같이 오버라이딩 함수를 직접 제공해야 하며, 어떤 상위 타입을 고를지는 `super<T>`로 결정

> #### 자바에서 코틀린의 메소드가 있는 인터페이스 구현하기
>
> 코틀린은 자바 6과 호환되도록 설계
>
> 코틀린의 구현이 있는 메소드의 경우, 자바에서는 인터페이스 + __메소드들을 정적 메소드로 구현한 클래스__로 조합해 구현

### `open`, `final`, `abstract` 변경자: 기본적으로 `final`

- 기본적으로 상속이 가능하면 __취약한 기반 클래스__ 문제를 야기
  ___클래스를 만든 사람과의 의도와 다르게 메소드를 오버라이딩할 위험이 있음___
- 오버라이드하게 의도한 클래스와 메소드가 아니라면 `final`로 선언 (feat. Effective Java)
  ___코틀린도 위 철학을 따름___

``` kotlin
open class RichButton : Clickable { // 상속 가능한 클래스
    fun disable() { } // 기본적으로 final, 오버라이딩 할 수 없음
    
    open fun animate() { } // 하위 클래스에서 오버라이딩 가능
    
    override fun click() { } // 오버라이딩한 메소드는 기본적으로 open, 오버라이딩을 제한할 경우 final 필요
}
```

- 코틀린은 기본적으로 `final`이며, 상속이나 오버라이딩을 허용하고 싶은 경우, `open` 변경자 사용
  ___프로퍼티도 마찬가지___

> #### 열린 클래스와 스마트 캐스트
>
> 클래스의 기본적인 상속 가능 상태가 `final`이면 다양한 경우에 __스마트 캐스트__가 가능
>
> 스마트 캐스트는 __변경될 수 없는 변수에만 적용 가능__
> _클래스의 프로터의 경우에_ `val`_이면서 커스텀 접근자가 없어야 함_
>
> 프로퍼티는 기본적으로 `final`이기 때문에 따로 고민할 필요 없음
> ___코드를 더 이해하기 쉽게 만듦___

```kotlin
abstract class Animated {
    abstract fun animate()
    
    open fun stopAnimating() { // 이 경우, 자바의 빈 메소드 역할
    }
    
    fun animateTwice() {
    }
}
```

- `abstract` 변경자 붙은 클래스와 메소드의 경우, 기본적으로 `open`
- __p.149에 정리된 표 참고__

### 가시성 변경자: 기본적으로 공개

- 가시성 변경자는 어떤 클래스에 대한 외부 접근을 제어
- 자바와 비슷
  - 자바: `public`, `protected`, `private` + __package-private__
  - 코틀린: `public`, `internal`, `protected`, `private`
- `internal` 키워드는 __진정한 캡슐화__를 제공
- __p.151에 정리된 표 참고__

```kotlin
internal open class TalkativeButton : Focusable {
    private fun yell() = println("Hey!")
    protected fun whisper() = println("Let's talk!")
}

fun TalkativeButton.giveSpeech() { // 오류: 가시성이 giveSpeech() 함수보다 낮음
    yell() // 오류: 가시성이 giveSpeech() 함수보다 낮음
    whisper() // 오류: 가시성이 giveSpeech() 함수보다 낮음
}
```

- __클래스와 메소드에 부여된 가시성보다 항상 같거나 높아야 함__

> #### 코틀린의 가시성 변경자와 자바
>
> 코틀린의 가시성 변경자는 자바와 어떻게 대치될까?
>
> 코틀린 `private` 클래스 --- 자바 __package-private__ 클래스
> ___why?___ 자바는 `private` 클래스를 만들 수 없음
>
> 코틀린 `internal` 클래스 --- 자바 `public` 클래스
> ___why?___ 마땅한 자바의 접근 제한자가 없음
>
> 위와 같게 대치되기 때문에 문제 발생. 특히나 `internal`의 경우
> ___코틀린에서 접근 불가능한 것이 자바에서는 접근 가능___
>
> 이를 해결하기 위해 코틀린 컴파일러가 `internal` 멤버의 __이름을 바꿈__ (못생기게)
> ___why?___
>
> - 메소드 이름이 우연히 겹쳐 오버라이드하는 경우를 방지
> - 모듈 외부에서 사용하는 일을 방지

### 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스

- 자바처럼 중첩 클래스 선언 가능
- 단, __중첩 클래스는 바깥 쪽 인스턴스에 접근할 수 없음__
  _직렬화 예시 참고_

```kotlin
class Button : View {
    override fun getCurrentState() : State = ButtonState()
    
    override fun restoreState(state: State) { ... }
    
    class ButtonState : State { ... }
}
```

- 아무 변경자가 없는 경우 __자바의__ `static` __중첩 클래스__
- 바깥쪽 클래스에 대한 참조를 담고 싶은 경우 `inner` 변경자 필요
- __p.155에 정리된 표 참고__

```kotlin
class Outer {
    inner class Inner {
        fun getOuterReference() : Outer = this@Outer
    }
}
```

- 바깥쪽 클래스의 인스턴스를 참조하는 경우 `this@Class`로 시작

### 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한

- 상위 클래스에 `sealed` 변경자를 붙이면 __상속 제한 가능__

```kotlin
sealed class Expr {
    class Num(val value: Int) : Expr()
    class Sum(val left: Expr, val right: Expr) : Expr()
}

fun eval(e: Expr) : Int =
    when (e) {
        is Expr.Num -> e.value
        is Expr.Sum -> eval(e.right) + eval(e.left)
    }
```

- `sealed` 클래스를 활용하면 __디폴트 분기가 필요 없음__
- `sealed` 클래스는 자동으로 `open`
- 새로운 클래스가 추가될 때, __컴파일 오류 발생__
  ___버그 발생을 줄일 수 있음___

> `sealed` 클래스는 코틀린 1.0과 1.1에서 차이를 보인다.
> _p.158 참고_

## 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스

- 코틀린은 __주 생성자__와 __부 생성자__가 있음
- 또, __초기화 블록__을 통해 초기화 로직 추가 가능

### 클래스 초기화: 주 생성자와 초기화 블록

```kotlin
class User(val nickname: String)
```

- 위와 같은 생성자를 __주 생성자__
- __주 생성자__는 `constructor`와 `init`을 사용해 __프로퍼티를 초기화__
  _p.159 ~ p.160 참고_

```kotlin
class User(val nickname: String, val isSubscribed: Boolean = true)
```

- 생성자 파라미터에도 __디폴트 값 사용 가능__
- 생성자도 __함수__기 때문에 __코틀린 함수__ 규칙을 따름

```kotlin
open class User(val nickname: String) { ... }
class TwitterUser(nickname: String) : User(nickname) { ... }

open class Button { ... }
class RadioButton : Button() { ... }
```

- 상속이 되어있다면, 반드시 상위 클래스의 주 생성자를 호출해야 함
- 이는, 상위 클래스가 별도 생성자가 없어도 동일
  ___빈 괄호___ `()` ___추가___
- 인터페이스는 생성자가 없기 때문에 `()` 필요없음

```kotlin
class Secretive private constructor() { ... }
```

- 주 생성자를 비공개 하고 싶은 경우, 위와 같이 생성자 정의

> #### 비공개 생성자에 대한 대안
>
> 유틸리티 함수를 담아두는 클래스를 코틀린에서 선언할 경우,
> 굳이 위처럼 비공개 생성자를 두지 않아도 됨
>
> 대안으로
>
> - 최상위 함수 선언
> - `object` 선언 (싱글턴)
>
> 두 가지가 있음

### 부 생성자: 상위 클래스를 다른 방식으로 초기화

- 부 생성자를 활용할 케이스는 매우 적음
  ___대신에 디폴트 파라미터와 이름 붙은 인자를 사용___
- 그래도 한 번 보자

```kotlin
open class View {
    constructor(ctx: Context) : super(ctx) { 
        this(ctx, MY_STYLE)
    }
    
    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) { ... }
}
```

- 자바와 비슷

### 인터페이스에 선언된 프로퍼티 구현

```kotlin
interface User {
    val nickname: String
}
```

- __추상 프로퍼티__가 들어있는 인터페이스
- 의미는  `nickname`__의 값을 얻을 수 있는 방법을 제공해라.__

```kotlin
class PrivateUser(override val nickname: String) : User

class SubscribingUser(val email: String) : User {
    override val nickname: String
        get() = email.substringBefore('@')
}

class FacebookUser(val accountId: Int) : User {
    override val nickname = getFacebookName(accountId)
}
```

- 각 클래스 별로 방법이 다름

```kotlin
interface User {
    val email: String
    val nickname: String
        get() = email.substringBefore('@')
}
```

- 인터페이스의 구현이 있는 함수처럼 추상 프로퍼티도 가능
- `nickname`은 반드시 오버라이딩하지 않아도 됨

### 게터와 세터에서 뒷받침하는 필드에 접근

```kotlin
class User(val name: String) {
    val address: String = "unspecified"
        set(value: String) {
            println("""
                Address was changed for $name:
               "$field" -> "$value".""".trimIndent())
            field = value
        }
}
```

- 게터에서 `field`는 읽기만 가능
- 세터에서 `field`는 읽기/쓰기 가능

> 차이점을 읽어봐도 잘 모르겠다...

### 접근자의 가시성 변경

- 접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같음
- 원한다면 접근자에 가시성을 변경 할 수 있음

```kotlin
class LenghCounter {
    var counter: Int = 0
        private set
    
    fun addWord(word: String) {
        counter += word.length
    }
}
```

## 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임

> Effective Java를 보면 나오는 내용
>
> 코틀린도 거의 동일하다고 판단됨

### 모든 클래스가 정의해야 하는 메소드

- 자바와 마찬가지로 코틀린 클래스는 `toString()`, `equals()`, `hashCode()` 등을 오버라이드해야 함

#### 문자열 표현: `toString()`

- 자바와 동일

#### 객체의 동등성: `equals()`

- 자바와 동일

> #### 동등성 연산에 `==`를 사용함
>
> 자바에서 `==` 연산자
>
> - 원시 타입: __동등성 비교__
> - 참조 타입: __동일 주소 비교__ (= 참조 비교)
>
> 코틀린에서 `==` 연산자
>
> - 원시 타입: 동등성 비교
> - 참조 타입: 동등성 비교 (`equals()` 호출과 동일한 효과)
>   참조 비교를 위해서는 `===` 연산자를 사용

#### 해시 컨테이너: `hashCode()`

- 자바와 동일

### 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성

- 위와 같은 불편함을 해소해주는 클래스
- `data` 변경자 필요

```kotlin
data class Clien(val name: String, val postalCode: Int)
```

- 자바에서 요구하는 모든 메소드를 포함함

#### 데이터 클래스와 불변성: `copy()` 메소드

- 데이터 클래스는 불변이어야 함
  `var` ___키워드가 사용 불가는 아니나 불변성이 깨짐___
- `copy()` 함수를 사용하면 복사 중에 값을 변경할 수 있음

```kotlin
class Client(val name: String, val postalCode: Int) {
    ...
    
    fun copy(name: String = this.name,
             postalCode: Int = this.postalCode) =
        Client(name, postalCode)
}
```

```kotlin
val lee = Client("이계영", 4122)
println(lee.copy(postalCode = 4000))
```

> 의문, 단일 책임 원칙에 위배되지 않는가?

### 클래스 위임: `by` 키워드 사용

