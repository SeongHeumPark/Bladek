## 람다 식과 멤버 참조

### 람다 소개: 코드 블록을 함수 인자로 넘기기

- 함수를 값처럼 다룸

```kotlin
button.setOnClickListener { /* 클릭 시 수행할 동작 */ }
```

### 람다와 컬렉션

- 코드의 중복을 제거하는 것은 중요
- 컬렉션에서 최대 값 찾기

```kotlin
// 일반적인 루프 작성
fun findTheOldest(people: List<Perseon>) {
    var maxAge = 0
    var theOldest: Person? = null
    
    for (person in people) {
        if (person.age > maxAge) {
           maxAge = person.age
            theOldest = person
        }
    }
    
    println(theOldest)
}

// 라이브러리 함수 사용
println(people.maxBy { it.age })
```

### 람다 식의 문법

![kotlin-lambda-expression](/Users/bladek/Naver/bladek/images/kotlin-lambda-expression.jpg)

```kotlin
people.maxBy({ p: Person -> p.age }) // 정식 람다
people.maxBy() { p: Person -> p.age } // 람다가 마지막 인자일 때(관습 문법)
people.maxBy { p: Person -> p.age } // 람다가 유일한 인자일 때
people.maxBy { p -> p.age } // 타입 추론 가능할 때
people.maxBy { it.age } // 디폴터 파라미터명인 it을 적용했을 때
```

> #### `it`
>
> 코드를 아주 간단히 만들어 줌
>
> 하지만 남용하지 말 것 (어느 it이 어느 it인지 나중에 보기 힘듦)
>
> __즉, 파라미터를 명시적으로 선언하는 것을 추천__

#### `run()`

- 코드의 일부분을 블록으로 감싸 실행할 필요가 있을 때 사용

```kotlin
{ println(42) }() // 람다 실행인데 읽기 어려움
run { println(42) } // 같은 동작 코드 깔끔
```

### 현재 영역에 있는 변수에 접근

- 람다를 함수 안에서 정의하면 __변수 포획__ 가능
  __변수 포획__: 파라미터, 로컬 변수(람다 앞에 선언된)까지 람다에서 사용
- 자바와 달리 `final`이 아닌 변수에도 접근 가능

```kotlin
fun printProblemCounts(responses: Collection<String>) {
    var clientErrors = 0
    var serverErrors = 0
    responses.forEach {
        if (it.startsWith("4")) {
            clientErrors++
        } else if (it.startWith("5")) {
            serverErrors++
        }
    }   
    ...
}
```

___어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있음___

### 멤버 참조

```kotlin
Person::age
```

- `::`를 사용하는 식을 __멤버 참조__라고 함
- 프로퍼티나 함수를 단 하나만 호출하는 __함수 값__을 만듦
- __멤버 참조__ 뒤에는 `()`를 넣으면 안됨
- __멤버 참조__는 그 멤버를 호출하는 람다와 같은 타입 _에타 변환_

```kotlin
// 아래 세 개는 모두 같은 동작
people.maxBy(Person::age)
people.maxBy { p -> p.age }
people.maxBy { it.age }

// 최상위 함수나 프로퍼티 참조 가능
fun salute() = println("Salute!")

>> run(::salute)

// 멤버 참조로 직접 위임 ??
val action = { person: Person, message: String -> sendEmail(person, message) }
val nextAction = ::sendEmail

// 생성자 참조
val createPerson = ::Person
val p = createPerson("Alice", 29)

// 확장 함수도 참조 가능
fun Person.isAdult() = age >= 21
val predicate = Person::isAdult
```

> #### 바운드 멤버 참조
>
> 멤버 참조를 생성할 때, __클래스 인스턴스를 함께 저장__
>
> 따라서, 호출 시 수신 대상 객체를 별도로 지정할 필요 X
>
> ```kotlin
> val p = Person("Dmitry", 34)
> val dmitrysAgeFunction = p::age
> println(dimitryAgeFunction())
> ```



## 컬렉션 함수형 API

> RxJava에서 공부했던 내용과 동일

### 필수적인 함수: `filter()`와 `map()`

#### `filter()` 함수: 람다에 들어간 조건이  `true`를 반환하는 원소만 모음

![filter](/Users/bladek/Naver/bladek/images/filter.png)

```kotlin
val list = listOf(1, 2, 3, 4)
println(list.filter { it % 2 == 0 })
```

#### `map()` 함수: 주어진 함수에 따라 변환하여 새로운 컬렉션을 만듦

![map](/Users/bladek/Naver/bladek/images/map.png)

```kotlin
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.map { it.name })

// 멤버 참조를 활용할 수도 있음
people.map(Person::name)
```

### `all()`, `any()`, `count()`, `find()`: 컬렉션에 술어 적용

#### `all()` 함수: 어떤 조건을 모든 원소가 만족하는가

#### `any()` 함수: 어떤 조건을 한 원소라도 만족하는가

#### `count()`  함수: 어떤 조건에 맞는 원소 개수 반환

#### `find()` 함수: 어떤 조건을 만족하는 첫번째 원소를 반환

### `groupBy()`: 리스트를 여러 그룹으로 이뤄진 맵으로 변경

![groupBy](/Users/bladek/Naver/bladek/images/groupBy.png)

```kotlin
val list = listOf("a", "ab", "b")
println(list.groupBy(String::first))
```

### `flatMap()`과 `flatten`: 중첩된 컬렉션 안의 원소 처리

![flatMap](/Users/bladek/Naver/bladek/images/flatMap.png)

```kotlin
books.flatMap { it.authors }.toSet()
```



## lazy 컬렉션 연산

- 컬렉션 함수는 컬렉션을 __즉시__ 생성
  즉, 매 단계마다 __임시 컬렉션이 생성됨__
- __시퀀스__를 사용하면 중간 임시 컬렉션을 사용하지 않을 수 있음

```kotlin
people.map(Person::name).filter { it.startsWith("A") } // 임시 리스트를 중간에 만듦

people.asSequence()
    .map(Person::name)
    .filter { it.startsWith("A") }
    .toList()
```

> #### 노트
>
> __큰 컬렉션__에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼아라

### 시퀀스 연산 실행: 중간 연산과 최종연산

- 중간 연산은 __항상 지연 계산__
- 최종 연산 전까지는 __아무 내용도 출력되지 않음__
- 최정 연산을 호출하면 __연기됐던 모든 계산이 수행__

### 시퀀스 만들기

- `generateSequence()` 함수를 사용

```kotlin
val naturalNumbers = generateSequence(0) { it + 1 }
val numbersTo100 = natureNumbers.takeWhile { it <= 100 }

println(numbersTo100.sum())
```



## 자바 함수형 인터페이스 활용

- 자바의 SAM 인터페이스에 람다를 적용하는 과정이므로 따로 정리 X



## 수신 객체 지정 람다: `with()`과 `apply()`

### `with()` 함수

- 라이브러리 함수
- 어떤 객체의 이름을 반복하지 않고도 객체에 다양한 연산을 수행할 수 있게 함

```kotlin
fun alphabet(): String {
    val stringBuilder = StringBuilder()
    return with(stringBuilder) {
        for (letter in 'A'..'Z') {
            this.append(letter)
        }
        append("\nNow I know the alphabet!")
        this.toString()
    }
}
```

- 위 코드를 보면 `with()` 함수는 파라미터가 두 개 있음 (`stringBuilder`와 lambda)

### `apply()` 함수

- `with()` 함수와 거의 동일
- 유일한 차이는 수신 객체를 반환

```kotlin
fun alpabet() = StringBuilder().apply {
    for (letter in 'A'..'Z') {
        append(letter)
    }
    append("\nNow I know the alphabet!")
}.toString()
```

- 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화할 때 유용