## 기본 요소: 함수와 변수

### Hello, World!

```kotlin
fun main(args: Array<String>) {
    println("Hello, World!")
}
```

- 함수 선언은 `fun` 키워드
- 파라미터 명 뒤에 타입을 씀
- 함수를 최상위 수준에 정의 가능
- 배열도 일반적인 클래스
- 표준 라이브러리의 래퍼 제공
- 세미콜론 없음

### 함수

- 기본 구조

  ```kotlin
  fun max(a: Int, b: Int) : Int {
      return if (a > b) a else b
  }
  ```

  > __문과 식의 구분__
  >
  > __식__: 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여 가능
  >
  > __문__: 값을 만들어 내지 않고 가장 안쪽 블록의 최상위 요소로 존재
  >
  > 코틀린은 루프를 제외한 대부분의 제어 구조가 __식__이다.

- 식이 본문인 함수

  ```kotlin
  fun max(a: Int, b: Int) : Int = if (a > b) a else b
  ```

  - 더 간결히 표현 가능
  - __블록이 본문인 함수__: 중괄호로 둘러 싸인 함수
  - __식이 본문인 함수__: 등호와 식으로 이뤄진 함수

- 타입 추론

  ```kotlin
  fun max(a: Int, b: Int) = if (a > b) a else b
  ```

  - 코틀린 is 정적 타입 지정 언어
  - __식이 본문인 함수__는 컴파일러가 본문 식을 분석해 __타입을 추론__함

### 변수

- 선언

  ```kotlin
  val a = 42
  val b: Int
  b = a
  ```

  - 초기화 식을 사용하는 경우 타입 생략 가능

- `var`과 `val`

  - `var`: 변경 가능
  - `val`: 변경 불가능

### 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
```

- __문자열 템플릿__ 예제
- 변수 앞에 `$` 추가
- 자바의 `"Hello, " + name + "!"`과 동일한 역할

```kotlin
fun main(args: Array<String>) {
    println("Hello, ${args[0]}!")
}
```

- `{}`를 이용하면 복잡한 식을 문자열 템플릿에 넣을 수 있음
- 한글을 문자열 템플릿과 사용할 경우 __unresolved reference__ 오류에 주의해야 함
  문자열 템플릿을 사용할 땐 `{}`를 붙이는 습관을 가지자!!!

```kotlin
fun main(args: Array<String>) {
    println("Hello, ${if (args.size > 0) args[0] else "someone"}!")
}
```

- 위 예제처럼 `{}`를 사용하면 `""`도 올 수 있음
- `{}`를 사용하면 문자열 템플릿 안에 문자열 템플릿도 넣을 수 있음

## 클래스와 프로퍼티

### 클래스

```java
public class Person {
    private final String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}
```

- 프로퍼티가 늘어날 때 문제가 생김

```kotlin
class Person(val name: String)
```

- 생성자 파라미터에만 영향이 있음
- 더 적은 코드로 클래스 생성 가능

### 프로퍼티

```kotlin
class Person {
    val name: String,
    var isMarried: Boolean
}
```

- 코틀린의 프로퍼티는 자바의 필드와 접근자 메소드를 대신
- `var`냐 `val`냐에 따라 다름
  - `var`: 수정 가능하므로 setter와 getter 제공
  - `val`: 수정 불가능하므로 getter만 제공

```java
Person person = new Person("Bob", true);
System.out.println(person.getName());
System.out.println(person.isMarried());
```

- 자바에서 코틀린으로 선언 클래스의 프로퍼티에 접근할 경우
  - `is`가 붙은 변수 외에는 `get`과 `set`이 prefix로 붙음
  - `is`가 붙은 변수는 getter에서는 `is`로 쓰고 setter에서는 `is` 대신 `set`을 씀

```kotlin
val person = Person("Bob", true)
println(person.name)
println(person.isMarried)
```

- 코틀린에서는 getter 호출대신 __프로퍼티에 직접 접근__
- setter도 마찬가지로 동작
- 코틀린의 getter는 커스텀 가능

### 커스텀 접근자

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolen
        get() = height == width
}
```

- `isSquare` 변수는 값을 저장할 필요가 없음

> 커스텀 접근자를 클라우드 앱의 Preference에 사용할 수 있음
>
> ```java
> public class UserPreference extends BasePreference {
>     ...
>     
>     public boolean is1TBUser() {
>         // 사이즈 비교
>     }
>     
>     ...
> }
> ```
>
> - 위와 같이 `is1TBUser()` 메서드가 있는 경우, 아래와 같이 작성 가능
>
> ```kotlin
> class UserPreference : BasePreference {
>     ...
>     
>     val is1TBUser: Boolean
>         get() = // 사이즈 비교
>     
>     ...
> }
> ```

### 코틀린 소스코드 구조: 디렉터리와 패키지

- 굳이 정리를...
- 특이한 점이라면 함수도 import 가능

## 선택 표현과 처리: `enum`과 `when`

### `enum` 클래스 정의

```kotlin
enum class Color(val r: Int, val g: Int, val b: Int) {
    RED(255, 0, 0), ORANGE(255, 165, 0), ...;
    
    fun rgb() = (r * 256 + b) * 256 + b
}
```

- 일반 클래스와 마찬가지로 선언
- `;`로 상수 목록과 함수 목록을 구분

### `when`으로 `enum` 클래스 다루기

```kotlin
fun getMnemonic(color: Color) =
    when (color) {
        Color.RED -> "Richard"
        Color.ORANGE -> "Of"
        ...
    }
```

- `when`은 `break`가 없어도 됨

```kotlin
fun getMnemonic(color: Color) = 
    when (color) {
        Color.RED, Color.ORANGE, Color.YELLOW -> "warm"
        Color.GREEN -> "netural"
        ...
    }
```

- 자바의 `switch`문을 대체하고 강력하며 간결함

### `when`과 임의의 객체를 함께 사용

```kotlin
fun mix(c1: Color, c2: Color) =
    when (setOf(c1, c2)) {
        setOf(RED, YELLOW) -> ORANGE
        setOf(YELLOW, BLUE) -> GREEN
        ...
        else -> throw Exception("Dirty color")
    }
```

- 자바의 `switch` 문과 달리 `when`의 분기 조건은 임의의 객체를 허용

### 인자 없는 `when` 사용

```kotlin
fun mixOptimized(c1: Color, c2: Color) =
    when {
        (c1 == RED && c2 == YELLOW) || (c1 == YELLOW && c2 == RED) -> ORANGE
        (c1 == YELLOW && c2 == BLUE) || (c1 == BLUE && c2 == YELLOW) -> GREEN
        ...
        else -> throw Exception("Dirty color")
    }
```

- 조건이 없으면 불리언 결과를 계산하는 식이어야 함

### 스마트 캐스트: 타입 검사와 타입 캐스트를 조합

```kotlin
interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr
```

- `Sum(Sum(Num(1), Num(2)), Num(4))` 를 수행할 때 타입 검사는?
- 자바는`instanceof` 키워드로 검사하고 블록 안에서 명시적 형변환 코드로 캐스팅 수행
- 코틀린은 `is` 키워드로 검사하면 컴파일러가 캐스팅을 수행

```kotlin
fun eval(e: Expr) : Int {
    if (e is Num) {
        return e.value
    }
    
    if (e is Sum) {
        return eval(e.right) + eval(e.left)
    }
    
    ...
}
```

- __컴파일러가 캐스팅__을 수행해주는 부분을 __스마트 캐스트__라고 함

## 대상을 이터레이션: `while`과 `for` 루프

### `while` 루프

- 자바와 동일

### 수에 대한 이터레이션: 범위와 수열

```kotlin
fun fizzBuzz(i: Int) = ...

for (i in 1..100) {
    print(fizzBuzz(i))
}

for (i in 100 downTo 1 step 2) {
    print(fizzBuzz(i))
}
```

- 범위를 표현하는 `..`는 양 끝을 포함하는 구간(=폐구간)임
- __수열__: 어떤 범위에 속한 값을 일정한 순서로 이터레이션하는 경우
- `downTo`는 역방향 수열
- `step 2`를 붙이면 증가 값이 2로 변경
- `until`은 끝을 포함하지 않는 구간(=반폐구간, 반개구간)을 표현할 때 씀

### 맵에 대한 이터레이션

```kotlin
val binaryReps = TreeMap<Char, String>()

for (c in 'A'..'F') {
    val binary = Integer.toBinaryString(c.toInt())
    binaryReps[c] = binary
}

for ((letter, binary) in binaryReps) {
    println("$letter = $binary")
}
```

- `..`는 문자 타입까지 적용 가능

- 자바의 `put()`, `get()` 메서드 대신에 `map[key] = value`, `map[key]`로 사용

  > 안드로이드의 `SparseArray`는 위와 같은 방식으로 이터레이션 할 수 있을까?
  >
  > 할 수 없음
  >
  > __참고__: [`withIndex`와 관련된 도큐먼트](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/with-index.html)

### `in`으로 컬렉션이나 범위의 원소 검사

```kotlin
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
fun isNotDigit(c: Char) = c !in '0'..'9'
```

```kotlin
fun recognize(c: Char) = when (c) {
    in '0'..'9' -> "It's a digit!"
    in 'a'..'z', in 'A'..'Z' -> "It's a letter!"
    else -> "I don't know.."
}
```

- `when`에서도 `in` 사용 가능
- `Comparable` __인터페이스를 구현한 클래스인 경우,__ `in` __키워드를 사용해 범위를 만들 수 있음__

## 코틀린의 예외 처리

- 자바와 달리 `throw` 앞에 `new`를 붙이지 않음

### `try`, `catch`, `finally`

- 자바에서는 __체크 예외__를 반드시 처리해야 함
  - `catch` 블록에서 처리
  - `throws`로 다시 던지기
- 코틀린은 체크 예외와 언체크 예외를 구분하지 않음
  - 잡아내도 되고 그러지 않아도 됨
  - 의미 없이 던지거나 처리한 예외는 실제 오류 발생을 방지하지 못할 수 있기 때문

### `try`를 식으로 이용

- `if`나 `when`과 마찬가지



