## 02. 기본 개념

### 변수

- `var`과 `val`
- __불변성__ : 다중 쓰레드 처리시 유용



### 형식 유추

- 컴파일 타임에 __타입 유추__ 가능

```kotlin
var title = "Kotlin"
```

> #### `Any`
>
> 자바의 `Object`와 동일
>
> 가지고 있는 함수도 `Object` 클래스와 동일
>
> 코틀린의 모든 클래스들은 `Any`를 상속받음

- __형식 명령__으로 변수의 타입을 알 수 있음 > _화살표 키 + Control + P_



### 엄격한 `null` 안정성

- `null` __검사 누락은 자바 시스템에서 가장 흔한 버그 패턴__

- `null` 허용 형식 존재 : `?`

#### 안전 호출

- 안전 호출 연산자 : `?.`

    ```kotlin
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val locked: Boolean? = savedInstanceState?.getBoolean("locked")
    }
    ```

    - 여기서도 `null` __허용 형식__ 발생

- __앨비스 연산자__ : `?:`

    ```kotlin
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val locked = savedInstanceState?.getBoolean("locked") ?: false
    }
    ```

    - `null` 허용을 피할 수 있음

#### not-null 주장

- not-null 주장 연산자: `!!`

  ```kotlin
  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      val locked = savedInstanceState!!.getBoolean("locked")
  }
  ```

  - `savedInstanceState`가 `null`이면 `NullPointerException`이 발생
  - __꼭 필요한 경우만 사용__ > ___해당 연산자는 잠재적인 위험이 있음을 개발자는 인지해야 함___

#### `let`

- `null` 허용을 다루기 위한 또 다른 기능

- 코틀린 표준 라이브러리 함수

  ```kotlin
  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      
      savedInstanceState?.let {
          printlin(it.getBoolean("isLocked"))
      }
  }
  ```


### `null` 가능성과  자바

- 자바에서 가져온 모든 변수는 `@NotNull`이 붙은 것 외에는 `null` __허용__
  이런 변수들을 모두, `null` 취급하고 검사하는 것은 그리 좋은 방법이 아님

- __플랫폼 형식__

  코틀린에서의 위 문제에 대한 해결책

  ```kotlin
  View! // View는 플랫폼 형식이다.
        // View!는 View or View?
  ```

- `findViewById()`

  코틀린 컴파일러는 `findViewById()` 함수가 `null` 허용인지 아닌지에 대한 정보를 모름
  그래서, __플랫폼 형식__을 반환



### 형변환

- 코틀린은 __스마트 형변환__을 통해 형변환을 간소화함

#### 안전/불안 형변환 연산자

- __불안 형변환 연산자__ : `as`

- __안전 형변환 연산자__ : `as?`

  `null`을 허용하는 형변환 연산자 > _변환할 수 없으면_ `null` _반환_

  ```kotlin
  val fragment: String = "ProductFragment"
  val productFragment: ProductFragment = 
      fragment as? ProductFragment ?: ProductFragment()
  ```

  - `null` 불허로 만들기 위해  `?:` 연산자 사용

#### 스마트 형변환

- 암시적 형변환을 수행

  ```kotlin
  if (animal is Fish) {
      animal.isHungry()
  }
  ```

#### `null` 가능성 스마트 형변환

- `null` 허용을 스마트 형변환을 통해 `null` 불허로 변경 가능

  ```kotlin
  fun verifyView(view: View?) {
      view ?: return // 앨비스 연산자로 간단하게 null 검사 가능
      
      view.isShown()
  }
  ```


### 기본 데이터 형식

- 코틀린은 모든 것이 객체 > ___primitive type도 객체 취급___

#### 숫자

- 자바의 기본형과 동일

  ```kotlin
  Double // 64bit
  Float  // 32bit
  Long   // 64bit
  Int    // 32bit
  Short  // 16bit
  Byte   //  8bit
  ```

#### `Char`

- 자바 `Char`과 동일

#### 배열

- 코틀린 표준 라이브러리 함수를 통해 생성 가능

  ```kotlin
  val array = arrayOf(1, 2, 3)
  val array = arrayOfNulls(3) // null로 채워짐
  val array - Array (5) { it * 2 } // 람다로 생성 가능
  ```

#### 부울 형식

- 자바 `Boolean`과 동일



### 복합 데이터 형식

#### 문자열

- 자바와 달리 인덱스로 접근 가능

  ```kotlin
  val str = "abcd"
  println(str[1])
  ```

- 표준 라이브러리의 확장 함수를 이용해 작업을 더 쉽게 작업 가능

#### 범위

- 일련의 값에 대한 시퀀스 정의

  ```kotlin
  for (i in 1..3) print(i) // 출력 123
  for (i in 5..1) print(i) // 출력 없음
  for (i in 5 downTo 1) print(i) // 출력 54321
  for (i in 3..6 step 2) print(i) // 출력 35
  for (i in 9 downTo 1 step 3) print(i) // 출력 963
  ```

#### 컬렉션

- 7장에서 자세히 소개



### 문과 식

- __식__ : 1개 이상의 __피연산자__와 0개 이상의 __연산자__로 구성되며, 1개의 값으로 평가
- __문__ : 작업을 수행하지만 __값을 갖지 않으므로 변수에 할당할 수 없음__
- 두 개의 차이를 아는 것이 중요



### 제어흐름

> Kotlin In Action에서 공부한 부분이므로 추가적인 내용만 참고
>
> __p.103에__ `break`__,__ `continue` __문과 라벨을 함께 사용하는 방법 참고__



### 예외

> Kotlin In Action에서 공부한 부분이므로 생략



### 컴파일 타임 상수

- `val` 변수가 초기화 지연 또는 컴파일 타임에 초기화 될 수 없는 상황들이 있음

- 컴파일 타임에 값을 알아야하는 경우 `const` __한정자__를 사용

  ```kotlin
  const val MAX_LOG_ENTRIES = 100
  
  @MyLogger(MAX_LOG_ENTRIES)
  class Test {
  }
  ```

- __제약__

  - __기본형__이나 `String`__형__으로 초기화할 것
  - __객체의 멤버__ 혹은 __최상위 수준__에 정의할 것
  - __맞춤형 Getter__를 가질 수 없다는 것



### 위임

- 8장에서 자세히 소개