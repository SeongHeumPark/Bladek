## `null` 가능성

- NPE를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성

### `null`이 될 수 있는 타입

- 코틀린은 명시적으로 `null`이 될 수 있는 타입을 지원

```java
int strLen(String s) {
    return s.length(); // s가 null이면 NPE 발생 (런타임)
}
```

```kotlin
fun strLen(s: String?) = s.length() // length() 함수 호출 불가
```

- `Type?`: `null`을 가질 수 있는 변수 혹은 프로퍼티
- `Type`과 `Type?`은 다른 타입 __(컴파일 시점에만)__

```kotlin
fun strLen(s: String?) = if (s != null) s.length() else 0 // null 검사 후, 내부에 접근 가능
```

### 타입의 의미

- [타입 (위키백과)](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C%ED%98%95)

> #### NPE를 다루는 다른 방법
>
> `@Nullable`, `@NonNull` 어노테이션
>
> - 표준 자바 컴파일러의 동작이 아님
> - 일관성 있게 적용된다는 보장이 없음
>
> 자바 8의 `Optional` 타입
>
> - `null`을 감싼 래퍼 타입
> - 래퍼기 때문에 런타임에 성능저하 유발
> - 전체 에코시스템에 일관성 있게 적용되기 힘듦

### 안전한 호출 연산자: `?.`

- `null` 검사와 함수 호출을 한 번의 연산으로 수행

```kotlin
fun printAllCaps(s: String?) {
    val allCaps: String? = s?.toUpperCase() // allCaps에는 null이 저장될 수 있음
    println(allCaps)
}
```

### 엘비스 연산자: `?:`

- `null` 대신 디폴트 값을 지정

```kotlin
fun foo(s: String?) {
    val t: String = s ?: "" // 기본 값이 null이 아니기 때문에 String 타입 가능
}
```

### 안전한 캐스트: `as?`

- `is`-`as` 패턴의 불편함을 해소
- `as?` 연산자는 변환할 타입이 없으면 `null`을 반환

```kotlin
class Person(val firstName: String, val lastName: String) {
    override fun equals(o: Any?): Boolean {
        val otherPerson = o as? Person ?: return false // 엘비스 연산자와 활용 가능
        ...
    }
    
    ...
}
```

### `null` 아님 단언: `!!`

- `null`이 될 수 없는 타입으로 변환
- 그럼에도 `null`이면 __NPE 발생__

```kotlin
fun ignoreNulls(s: String?) {
    val sNotNull: String = s!!
    ...
}
```

- `!!` 연산자를 오용하지 말 것

```kotlin
// 이런 식으로 한 줄에 쓰지 말 것
person.company!!.address!!.country // 어떤 식에서 NPE가 발생했는지 파악하기 어려움
```

###  `let()` 함수

- `null` 가능 타입을 인자로 받아 검사 후, 람다 블록에 `null`이 아닌 타입으로 전달
  즉, `null`이 들어오면 블록 안의 동작은 하지 않음

```kotlin
email?.let { email -> sendEmailTo(email) }
```

- `let()` 함수가 중첩해서 쓰이는 경우, 그냥 `if` 식을 이용해 검사하는게 깔끔

### 나중에 초기화할 프로퍼티

- 객체를 나중에 초기화해야할 프레임워크가 많음
- 이를 위해 코틀린은 `lateinit` 변경자를 지원

```kotlin
class MyService {
    fun performAction(): String = "foo"
}

class MyTest {
    private lateinit var myService: MyService // 반드시 var이어야 함
    
    @Before fun setup() {
        myService = MyService()
    }
    
    @Test fun testAction() {
        Assert.assertEquals("foo", myService.performAction())
    }
}
```

- `lateinit`으로 선언된 변수가 초기화 되기 전에 접근하면 예외 발생

### `null`이 될 수 있는 타입 확장

- 확장 함수를 `null`을 다루는 강력한 도구로 활용 가능

```kotlin
fun String?.isNullOrBlank() = this == null || this.isBlank()
```

- 코틀린에서 `null`이 될 수 있는 타입의 확장 함수 안에서는 항상  `null` 검사가 필요
  자바에서는 NO

### 타입 파라미터의 `null` 가능성

- 파라미터 타입에 `?`가 붙지 않았음에도 `null`이 들어올 수 있는 경우

```kotlin
fun <T> printHashCode(t: T) {
    println(t?.hashCode()) // 제네릭을 이용하면 이와 같이 안전 호출 연산자를 활용해야 함
}

fun <T: Any> printHashCode(t: T) { // 상한을 이용해 null이 될 수 있는 타입의 전달을 막음
    println(t.hashCode())
}
```

### 널 가능성과 자바

- `@Nullable`, `@NotNull` 어노테이션은 코틸린에서 `null` 가능성 여부를 알 수 있음
- 코틀린에서 `null` 가능성 여부를 모르는 자바의 타입을 __플랫폼 타입__이라 함

#### 플랫폼 타입

- 자바의 타입과 마찬가지로 생각하면 됨

> #### 왜 플랫폼 타입을 도입했을까?
>
> 불필요한 `null` 체크를 피하기 위해
> 자바의 타입을 가져온 경우, 프로그래머들에게 그 타입을 제대로 처리하도록 책임을 부여

- 코틀린 컴파일러에서만 플랫폼 타입을 확인할 수 있음

```kotlin
val i: Int = person.name
>>> ERROR: Type mismatch: inferred type is String! but Int was expected
```

- `String!`은 자바에서 온 타입
  `null` 가능성에 대한 정보가 없음을 뜻함

#### 상속

- 자바 클래스나 인터페이스를 코틀린에서 상속/구현할 경우, `null` 가능성을 프로그래머가 결정해야 함

```java
interface StringProcessor {
    void process(String value);
}
```

```kotlin
// null 불가
class StringPrinter : StringProcessor {
    override fun process(value: String) {
        println(value)
    }
}

// null 가능
class NullableStringPrinter : StringProcessor {
    override fun process(value: String?) {
        let(value) { value -> println(value) }
    }
}
```



## 코틀린의 원시 타입

### 원시 타입: `Int`, `Boolean` 등

- 코틀린에서는 모든 원시 타입을 객체로 표현
- 컴파일 타임에 __자바의 원시 타입으로 바뀌므로 비효율적이지 않음__
- 종류
  - 정수 타입: `Byte`, `Short`, `Int`, `Long`
  - 부동소수점 타입: `Float`, `Double`
  - 문자 타입: `Char`
  - 불리언 타입: `Boolean`

### 널이 될 수 있는 원시 타입: `Int?`, `Boolean?`  등

- 컴파일 타임에 __자바의 래퍼 타입으로 변환__

```kotlin
data class Person(val name: String, val age: Int? = null) {
    fun isOlderThan(other: Person): Boolean? {
        if (age == null || other.age == null) { // 값을 사용하기 전에 반드시 null 체크 필요
            return null
        }
        return age > other.age
    }
}
```

### 숫자 변환

- 코틀린은 자바와 다르게 숫자의 자동 변환을 지원하지 않음 (except. 숫자 리터럴)

```kotlin
val i = 1
val l: Long = i // 컴파일 오류

val i = 1
val l: Long = i.toLong() // 변환 함수를 호출
```

- 숫자 리터럴을 사용할 경우에는 예외

```kotlin
val b: Byte = 1
val l = b + 1L // b + 1L은 Long으로 저장됨
```

- 코틀린도 자바와 똑같이 overflow가 발생할 수 있음
  코를린은 overflow 검사에 추가 비용을 들이지 않음(?)

### `Any`, `Any?`: 최상위 타입

- 자바의 `Object`
- `null` 불가능한 `Any`와 `null` 가능한 `Any?` 타입이 각각 존재

### `Unit` 타입: 코틀린의 `void`

```kotlin
// 아래 두 함수는 같음
fun f(): Unit { ... }
fun f() { ... } // 즉, 아무 값을 반환하지 않는 것이 아님
```

- `Unit`은 모든 기능을 갖는 일반적인 타입
  타입 인자로도 활용 가능

```kotlin
interface Processor<T> {
    fun process(): T
}

class NoResultProcessor : Processor<Unit> {
    override fun process() {
        ...
    }
}
```

> #### 왜 `Void`가 아니라 `Unit`일까?
>
> 함수형 프로그래밍에서 `Unit`은 단 하나의 인스턴스만 갖는 타입을 의미 (코틀린도 동일)
> 하지만, 코틀린에서는 `Void`도 사용하지 않음

### `Nothing` 타입: 이 함수는 결코 장성적으로 끝나지 않는다

- 자바의 `Void`와 비슷
- 아무 값을 포함할 수 없음
- __함수의 반환 타입, 반환 타입으로 쓰일 타입 파라미터로만 활용 가능__

```kotlin
val address = company.address ?: fail("No address")
println(address.city)
```



## 컬렉션과 배열

### `null` 가능성과 컬렉션

- `List<Int?>`: 리스트 안의 값이 `null`이 될 수 있음
- `List<Int>?`: 리스트 자체가 `null`이 될 수 있음

```kotlin
fun addValidNumbers(numbers: List<Int?>) {
    var sumOfValidNumbers = 0
    var invalidNumbers = 0
    for (number in numbers) {
        if (number != null) { // number에 null 체크는 당연
            sumOfValidNumbers += number
        } else {
            invalidNumbers++
        }
    }
    
    ...
}
```

```kotlin
fun addValidNumbers(numbers: List<Int?>) {
    var validNumbers = numbers.filterNotNull()
    
    ...
}
```

- `filterNotNull()`의 반환 타입은 `List<Int>`

### 읽기 전용과 변경 가능한 컬렉션

- 코틀린에서는 읽기 전용과 아닌 컬렉션 인터페이스를 분리

```kotlin
fun <T> copyElements(source: Collection<T>, target: MutableCollection<T>) {
    for (item in source) {
        target.add(item) // 변경 가능한 컬렉션에 원소 추가
    }
}
```

- 가능하면 __항상 읽기 전용 인터페이스를 사용__하는 것을 일반 규칙으로 삼을 것

### 코틀린 컬렉션과 자바

- 컬렉션 인터페이스 계층

![collection_interface](../images/collection_interface.png)

- 컬렉션 생성 함수

| 컬렉션 타입 | 읽기 전용 타입 | 변경 가능 타입                                            |
| ----------- | -------------- | --------------------------------------------------------- |
| `List`      | `listOf`       | `mutableListOf`, `arrayListOf`                            |
| `Set`       | `setOf`        | `mutableSetOf`, `hashSetOf`, `linkedSetOf`, `sortedSetOf` |
| `Map`       | `mapOf`        | `mutableMapOf`, `hashMapOf`, `linkedMapOf`, `sortedMapOf` |

- 컬렉션을 자바로 넘기는 코틀린 프로그램을 작성한다면,
  호출하려는 __자바 코드가 컬렉션을 변경할지 여부에 따라 올바른 파라미터 타입을 사용할 책임이 있음__

### 컬렉션을 플랫폼 타입으로 다루기

- 자바로 작성된 클래스, 인터페이스를 코틀린에서 상속/구현할 때, 컬렉션을 어떻게 처리해야 할지 결정해야 함
  - 컬렉션이 `null`이 될 수 있는가?
  - 컬렉션의 원소가 `null`이 될 수 있는가?
  - 오버라이드하는 메소드가 컬렉션을 변경할 수 있는가?

```java
interface FileContentProcessor {
    void processContents(File path, byte[] binaryContents, List<String> textContents);
}
```

```kotlin
class FileIndexer : FileContentProcessor {
    override fun processContents(path: File, binaryContents: ByteArray?, textContents: List<String>?)
}
```

- 상황에 맞게 컬렉션의 `null` 가능성을 지정해야 함

### 객체의 배열과 원시 타입의 배열

- 코틀린에서 배열을 만드는 방법

  - `arrayOf` 함수 호출로 생성

  - `arrayOfNull` 함수 호출로 생성

  - `Array` 생성자에 배열 크기와 람다를 넘겨 생성

    ```kotlin
    val letters = Array<String>(26) { i -> ('a' + i).toString() }
    ```

- 원시 타입의 배열을 만드는 방법

  - 각 배열 타입의 생서자는 `size` 인자를 넘겨 생성

    ```kotlin
    var fiveZeros = IntArray(5)
    ```

  - 팩토리 함수에 여러 값을 가변 인자로 넘겨 생성

    ```kotlin
    var fiveZeros = IntArrayOf(0, 0, 0, 0, 0)
    ```

  - 크기와 람다를 인자로 받는 생성자 사용

    ```kotlin
    val squares = IntArray(5) { i -> (i + 1) * (i + 1)}
    ```
