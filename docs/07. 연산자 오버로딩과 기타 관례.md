## 관례

- 어떤 언어의 기능과 미리 정해진 이름의 함수를 연결해주는 기법
- 코틀린은 관례에 의존
- 기존 자바 클래스를 코틀린 언어에 적용하기 위해 관례를 채택



## 산술 연산자 오버로딩

- 관례를 사용하는 가장 단순한 예

### 이항 산술 연산 오버로딩

```kotlin
// 멤버 함수로 정의
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point { // 관례를 따르는 함수
        return Point(x + other.x, y + other.y)
    }
}
```

```kotlin
// 확장 함수로 정의
operator fun Point.plus(other: Person): Point {
    return Point(x + other.x, y + other.y)
}
```

```kotlin
val p1 = Point(10, 20)
val p2 = Point(30, 40)
println(p1 + p2)
```

- `operator` 키워드가 없으면서 관례에 사용하는 함수의 이름을 쓰면 오류 발생

  > "operator modifier is required..."

```kotlin
operator fun Point.times(scale: Double): Point {
    return Point((x * scale).toInt(), (y * scale).toInt())
}

// 교환 법칙을 지원하지 않으므로 반대의 경우는 아래와 같이 반대의 경우를 정의해야 함
operator fun Double.times(point: Point): Point {
    return Point((this * point.x).toInt(), (this * point.y).toIny())
}
```

```kotlin
operator fun Char.times(count: Int): String { // 리턴하는 결과가 다름
    return toString().repeat(count)
}
```

- `operator` 키워드가 붙은 함수도 __오버라이딩 가능__

> #### 비트 연산자에 대해 특별한 연산자 함수를 사용하지 않는다.
>
> 대신, 중위 연산자 표기법으로 지원
>
> - `shl` - 왼쪽 시프트
>
>   … (p.310 참고)

### 복합 대입 연산자 오버로딩

- `+=`, `-=` 등을 일컬어 __복합 대입 연산자__라 함

```kotlin
operator fun <T> MutableCollection<T>.plusAssign(element: T) {
    this.add(element)
}
```

- `plus`와 `plusAssign`를 동시에 정의하지 말 것 (p.312 참고)
- 컬렉션에 대해 두 가지 접근 방법을 함께 제공
  - `+`와 `-`는 __항상 새로운 컬렉션을 반환__
  - `+=`과 `-=`는 __항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태를 변경__
  - 읽기 전용 컬렉션에서 `+=`과 `-=`은 __변경을 적용한 복사본을 반환__

### 단한 연산자 오버로딩

- 이항 연산자랑 마찬가지 내용 (정리 X)



## 비교 연산자 오버로딩

- 코틀린에서는 `==` 비교 연산자를 직접 사용할 수 있음
  `equals`와 `compareTo`를 사용한 코드 보다 더 간결하며 이해하기 쉬움

### 동등성 연산자: `equals`

```kotlin
class Point(val x: Int, val y: Int) {
    // Any 클래스에 operator로 선언되어 있어서 override만 필요
    override fun equals(obj: Any?): Boolean {
        if (obj === this) return true
        if (obj !is Point) return false
        return obj.x == x && obj.y == y
    }
}
```

- 식별 비교 연산자 `===`는 자바 `==` 연산자와 같음
  __자신의 두 피연산자가 서로 같은 객체를 가리키는지 비교__
- `equals`를 구현할 때, `===`를 사용해 자기 자신과의 비교를 최적화하는 경우가 많음
- `===`__를 오버로딩할 수 없음__

### 순서 연산자: `compareTo`

- 코틀린도 자바와 동일하게 `Comparable` 인터페이스를 지원함

```kotlin
class Person(val firstName: String, val lastName: String) : Comparable<Person> {
    override fun compareTo(other: Person): Int {
        return compareValueBy(this, other, Person::lastName, Person::firstName)
    }
}
```



## 컬렉션과 범위에 대해 쓸 수 있는 관례

- 가장 많이 사용하는 연산은 __인덱스를 사용해 원소를 읽거나 쓰는 연산__과 __어떤 값이 컬렉션에 속해있는지 검사하는 연산__

### 인덱스로 원소에 접근: `get`과 `set`

- 인덱스 연산자도 관례를 따름

```kotlin
operator fun Point.get(index: Int): Int {
    return when(index) {
        0 -> x
        1 -> y
        else -> throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}
```

```kotlin
data class MutablePoint(var x: Int, var y: Int)

operator fun MutablePoint.set(index: Int, value: Int) {
    when(index) {
        0 -> x = value
        1 -> y = value
        else -> throw IndexOutOfBoundsException("Invalid coordinate $index")
    }
}
```

### `in` 관례

- `in` 연산자와 대응하는 함수는 `contains`

```kotlin
data class Rectangle(val upperLeft: Point, val lowerRight: Point)

operator fun Rectangle.contains(p: Point): Boolean {
    // until을 쓰면 열린 범위 (끝 값이 포함되어 있지 않음)
    return p.x in upperLeft.x until lowerRight.x && p.y in upperLeft.y until lowerRight.y
}
```

### `rangeTo` 관례

- `..` 연산자는 `rangeTo` 함수를 간략하게 표현하는 방법

 ```kotlin
operator fun <T: Comparable<T>> T.rangeTo(that: T): CloasedRange<T>
 ```

```kotlin
val now = LocalDatet.now()
val vacation - now..now.plusDay(10)

println(now.plusWeeks(1) in vacation)
```

### `for` 루프를 위한 `iterator` 관례

- `iterator` 또한 관례이므로 메소드를 확장 함수로 정의 가능

```kotlin
operator fun ClosedRange<LocalDate>.iterator(): Iterator<LocalDate> = object : Iterator<LocalDate> {
    var current = start

    override fun hasNext() = current <= endInclusive
    
    override fun next() = current.apply {
        current = plusDays(1)
    }
}
```



## 구조 분해 선언과 `component` 함수

- 구조 분해를 사용하면 복합적인 값을 분해해서 여러 변수를 한꺼번에 초기화할 수 있음

```kotlin
val p = Point(10, 20)
val (x, y) = p

println(x)
println(y)
```

### 구조 분해 선언과 루프

- 변수 선언이 들어갈 수 있는 장소라면 어디든 구조 분해 선언 사용 가능

```kotlin
fun printEntries(map: Map<String, String>) {
    for ((key, value) in map) {
        println("$key -> $value")
    }
}
```



## 프로퍼티 접근자 로직 재활용: 위임 프로퍼티

- 값을 뒷받침하는 필드에 단순히 저장하는 것보다 더 복잡한 방식으로 작동하는 프로퍼티를 쉽게 구현 가능
- __위임__: 객체가 직접 작업을 수행하지 않고 다른 도우미 객체가 그 작업을 처리하게 맡기는 디자인 패턴
- __위임 객체__: 작업을 처리하는 도우미 객체

### 위임 프로퍼티 소개

- `by` 뒤에 있는 식을 계산해서 위임에 쓰일 객체를 얻음

```kotlin
class Delegate {
    operator fun getValue(...) { ... }
    operator fun setValue(...) { ... }
}

class Foo {
    var p: Type by Delegate()
}
```

```kotlin
val foo = Foo()
val oldValue = foo.p // delegate.getValue() 호출됨
```

### 위임 프로퍼티 사용: `by lazy()`를 사용한 프로퍼티 초기화 지연

- __지연 초기화__: 객체의 일부분을 초기화하지 않고 남겨뒀다가 실제로 그 부분의 값이 필요할 경우 초기화할 떄 쓰이는 패턴

```kotlin
class Email { ... }

fun loadEmails(person: Person): List<Email> {
    println("${person.name}의 이메일을 가져옴")
    return listOf(...)
}
```

```kotlin
class Person(val name: String) {
    val emails by lazy { loadEmails(this) }
}
```

- `lazy()` 함수는 기본적으로 스레드에 안전
- 필요에 따라 동기화에 사용할 락을 `lazy()` 함수에 전달할 수 있음
- 다중 스레드 환경에서 사용하지 않을 프로퍼티를 위해 `lazy()` 함수가 동기화를 하지 못하게 막을 수 있음

### 위임 프로퍼티 구현

- 객체 변경을 UI에 알려야 하는 경우, 위임 프로퍼티로 구현 가능

```kotlin
class ObservableProperty(var propValue: Int, val changeSupport: PropertyChangeSupport) {
    operator fun getValue(p: Person, prop: KProperty<*>): Int = propValue
    operator fun setVaule(p: Person, prop: KProperty<*>, newValue: Int) {
        val oldValue = propValue
        propValue = newValue
        
        changeSupport.firePropertyChange(prop.name, oldValue, newValue)
    }
}
```

```kotlin
class Person(val name: String, age: Int, salary: Int) : PropertyChangeAware() {
    var age: Int by ObservableProperty(age, changeSupport)
    var salary: Int by ObservableProperty(salary, changeSupport)
}
```

- 위 예제는 코틀린 표준 라이브러리를 사용하면 더 간단하게 구현 가능

### 위임 프로퍼티 컴파일 규칙

```kotlin
// 위임 프로퍼티가 있는 클래스 정의
class C {
    var prop: Type by MyDelegate()
}

val c = C()
```

```kotlin
// 코틀린 컴파일러의 해석
class C {
    private val <delegate> = MyDelegate()
    var prop: Type
    get() = <delegate>.getValue(this, <property>)
    set(value: Type) = <delegate>.setValue(this, <property>, value)
}
```

### 프로퍼티 값을 맵에 저장

- __확장 가능한 객체__: 자신의 프로퍼티를 동적으로 정의할 수 있는 객체가 위임 프로퍼티를 활용해서 만들어 졌을 때

```kotlin
class Person {
    private val _attributes = hashMapOf<String, String>()
    
    fun setAttribute(attrName: String, value: String) {
        _attributes[attrName] = value
    }
    
    val name: String by _attributes
}
```

- `Map`과 `MutableMap` 인터페이스에 대해 `getValue`와 `setValue`를 확장 함수로 표준 라이브러리에서 제공함

### 프레임워크에서 위임 프로퍼티 활용

- 객체 프로퍼티를 저장하거나 변경하는 방법을 바꿀 수 있으면 프레임워크를 개발할 때 유용

```kotlin
object Users : IdTable() {
    val name = varchar("name", length = 50).index()
    val age = integer("age")
}

class User(id: EntityID) : Entity(id) {
    var name: String by Users.name
    var age: Int by Users.age
}
```

