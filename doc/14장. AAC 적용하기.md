## 14.1 안드로이드 아키텍처 컴포넌트란?

- 안드로이드의 환경 변화를 유연하게 대응하는 라이브러리

- 종류

  | 기능      | 설명                                                         |
  | --------- | ------------------------------------------------------------ |
  | Lifecycle | 액티비티나 프래그먼트의 생명주기를 쉽게 감지하고 이에 따른 작업을 수행할 수 있게 도와줌 |
  | LiveData  | 지속적으로 변할 수 있는 값을 생명주기에 맞게 전달할 수 있도록 도와줌 |
  | ViewModel | 생명주기 변화에 맞서 UI 표시에 필요한 데이터를 관리할 수 있도록 도와줌 |

- 기타 라이브러리

  | 라이브러리 | 설명                                                         |
  | ---------- | ------------------------------------------------------------ |
  | Room       | SQLite 데이터베이스와 관련된 작업을 간편하게 사용할 수 있게 도와줌 |
  | Paging     | 다수의 데이터 중 일부 데이터를 불러와 화면에 표시하고, 다음 데이터를 계속 표시하는 작업을 쉽게 구현할 수 있게 도와줌 |

## 14.2 생명주기에 맞는 동작 구현하기: Lifecycle 클래스

 ```kotlin
// 자원을 관리하는 클래스
class MyResource(private val context: Context) {
    fun loadResource() {
        // 자원을 사용할 수 있도록 준비
    }
    
    fun releaseResource() {
        // 자원을 반환
    }
}

class MainActivity : AppCompatActivity {
    val resource: MyResource = ...
    
    override fun onStart() {
        super.onStart()
        // 액티비티가 화면에 표시되면 자원을 사용할 수 있도록 준비
        resource.loadResource()
    }
    
    override fun onStop() {
        super.onStop()
        // 액티비티가 화면에서 사라지면 자원을 반환
        resource.releaseResource()
    }
    
    ...
}
 ```

- 생명주기에 맞춰 작업이 필요한 요소가 많아질 경우

  -  `MainActivity` 클래스에 생명주기별 콜백 함수 추가 필요


  - 가독성 저하
  - 실수 유발
  - 버그 발생

- Lifecycle 라이브러리는 위와 같은 문제를 줄이는데 도움을 줌

### Lifecycle의 구성 요소

- 생명주기 자체와 관련된 요소인 `Event`, `State`

  | `Lifecycle.Event` 내 열거형 상수 | 대응하는 생명주기 콜백 함수    |
  | -------------------------------- | ------------------------------ |
  | `ON_ANY`                         | 모든 생명주기 콜백 함수에 대응 |
  | `ON_CREATE`                      | `onCreate()`                   |
  | `ON_DESTROY`                     | `onDestroy()`                  |
  | `ON_PAUSE`                       | `onPause()`                    |
  | `ON_RESUME`                      | `onResume()`                   |
  | `ON_START`                       | `onStart()`                    |
  | `ON_STOP`                        | `onStop()`                     |

  | `Lifecycle.State` 내 열거형 상수 | 대응하는 액티비티/프래그먼트 상태                            |
  | -------------------------------- | ------------------------------------------------------------ |
  | `CREATED`                        | `onCreate()` 콜백 함수가 호출되어 화면에 표시될 준비가 끝난 상태 |
  | `DESTROYED`                      | 액티비티/프래그먼트가 완전히 종료된 상태                     |
  | `INITIALIZED`                    | 액티비티/프래그먼트 객체가 생성되었지만, 아직 화면에 표시할 준비가 되지 않은 상태 |
  | `RESUMED`                        | 액티비티/프래그먼트가 화면에 표시되고 있으며 사용자와 상호작용(터치등)이 가능한 상태 |
  | `STARTED`                        | 액티비티/프래그먼트가 화면에 표시되었지만, 아직 사용자와 상호작용을 할 수 없는 상태 |

- 이벤트 발생 및 관찰과 관련된 요소인 `LifecycleOwner`, `LifecycleObserver`로 구성

## 14.3 SQLite 데이터베이스 쉽게 사용하기: 룸 라이브러리

- SQLite를 사용하여 개발할 때 여러 종류의 문제가 발생
  - 오타 발생시 컴파일 시점에서 발견할 수 없음
  - 결과를 객체 형태로 변환하기 위한 코드량이 많고 복잡함
  - 메인 스레드에서 DB 작업을 오래 수행하면 UI 업데이트가 지연되거나 ANR 발생
- 이러한 문제점들을 룸 라이브러리로 해결 가능

### 룸 라이브러리 소개

- SQLite를 좀 더 체계적으로 사용 가능
- 구성 요소
  - Room Database
  - Data Access Object
  - Entity

### 룸 데이터베이스

- 데이터 베이스 생성, 연결, 버전 관리등 실제 DB파일과 밀접한 작업을 담당

- `RoomDatabase`를 상속한 추상 클래스로 선언해야 함

- `@Database` 어노테이션을 사용하여 `Entity`와 __버전__을 지정

  ```kotlin
  @Database(entities = arrayOf(User::class, Address:class), version = 1)
  abstract class MemberDatabase : RoomDatabase() {
      
      abstract fun userDao(): UserDao
      
      abstract fun addressDao(): AddressDao
  }
  ```

  - 룸 데이터베이스 클래스 정의 예시

  ```kotlin
  val database: MemberDatabase = Room.databaseBuilder(
      context, MemberDatabase::class.java, "database.db").build()

  val addressDao = database.addressDao()
  ```

  - 룸 데이터베이스 인스턴의 생성 및 사용 예시

### 데이터 접근 객체

- 데이터베이스를 통해 수행할 작업을 정의한 클래스

- 삽입, 수정, 삭제, 읽기 작업 등을 함수 형태로 정의

- 인터페이스나 추상 클래스로 정의 가능

- `@Dao` 어노테이션을 반드시 붙여야 함

  ```kotlin
  @Dao
  interface UserDao {
      @Query("SELECT * from users")
      fun getUsers() : List<User>
      
      @Query("SELECT * from users WHERE id = :userId")
      fun getUser(userId: Long) : User
      
      @Query("SELECT * from users WHERE id IN (:userIds)")
      fun getUsersIn(userIds: Array<Long>) : List<User>
      
      @Query("DELETE from users")
      fun clearUsers()
      
      @Insert(onConlfict = OnConflictStrategy.REPLACE)
      fun addUser(user: User)
      
      @Update
      fun updateUser(newUser: User)
      
      @Delete
      fun deleteUser(user: User)
  }
  ```

  - 데이터 접근 객체의 구현 예시
  - `@Qeury` 어노테이션 외에 `@Insert`, `@Update`, `@Delete` 어노테이션 사용 가능

### 엔티티

- 데이터베이스에 저장할 데이터의 형식을 정의

- 각 엔티티가 하나의 테이블을 구성

- `@Entity` 어노테이션을 사용하여 정의

- 엔티티는 최소 하나의 Primary Key를 지정해야 함

  - `@PrimaryKey` 어노테이션 사용

- DB에 저장하고 싶지 않은 필드는 `@Ignore` 어노테이션을 필드에 추가

  ```kotlin
  @Entity
  class User(
      @PrimaryKey val id: Long,
      val name: String,
      val address: String,
      @Ignore var memo: String)

  @Entity(primaryKes = arrayOf("id", "name"))
  class User(
      val id: Long,
      val name: String,
      val address: String,
      @Ignore var memo: String)
  ```

  ​