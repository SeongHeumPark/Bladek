## 5.1 코틀인에서 자바 코드 사용하기

### Getter/Setter의 프로퍼티화

- 자바 빈(Bean) 클래스는 코틀린에서 __프로퍼티__처럼 사용 가능

  ```java
  class Person {
      private String name;
      private String address;
      
      Person(String name, String address) {
          this.name = name;
          this.address = address;
      }
      
      public String getName() {
          return name;
      }
      
      public void setAddress(String address) {
          this.address = address;
      }
      
      public String getAddress() {
          return address;
      }
  }
  ```

  ```kotlin
  val person = Person("John Doe", "Somewhere")

  println("name: ${person.name} address: ${person.address}")

  // 실패: 컴파일 에러
  person.name = "Jane Doe"

  // 성공
  person.address = "Nowhere"
  ```

  - Getter/Setter 선언 여부에 따라 코틀린의 `get()`, `set()` 함수와 대응됨

### 가변 인자를 받는 메서드

- 앞 장에서 배웠듯이 __스프레드 연산자__`*`를 사용하여 인자를 전달

### `Object` 클래스 내 메서드

- 코틀린에서는 `Any` 클래스로 처리

- 하지만, 코틀린은 다른 플랫폼에서도 사용할 수 있도록 설계되었기에 `Object` 클래스의 메서드 중 일부만 지원

- `Any` 클래스에서 지원하는 함수

  - `toString()`
  - `hashCode()`
  - `equals()`

- `wait()`와 `notify()` 메서드의 경우, __확장 함수__ 형태로 지원

  ```kotlin
  val str = "Lorem ipsum"
  (str as java.lang.Object).wait()
  (str as java.lang.Object).notify()
  ```

- `getClass()` 메서드를 코틀린에서 사용하는 방법

  ```kotlin
  val str = "Lorem ipsum"

  // ::class 사용
  val kotlinClass: KClass<out String> = str::class

  // ::class.java
  val javaClass: Class<out String> = str::class.java
  ```

- `clone()` 메서드를 사용하기 위해서는 직접 `Cloneable` 인터페이스를 구현해야 함

  ```kotlin
  class Person(val name: String, val address: String) : Clonable {
      override fun clone(): Any {
          ...
      }
  }
  ```

- `finalize()` 메서드는 단순히 구현만 하면되나, 절대 `private`으로 선언되어선 안됨

### Single Abstract Method 변환

- 코틀린에서는 자바로 작성된 인터페이스에 대해 SAM변환을 지원

- 예제

  ```kotlin
  val button = ...
  button.setOnClickListener(object: View.OnClickListener {
      override fun onClick(v: View) {
          ...
      }
  })

  // 람다 사용
  // onClick() 함수는 View를 인자로 받고 아무 것도 반환하지 않으므로 아래와 같이 표현 가능
  button.setOnClickListener({ view: View -> Unit 
      ...
  })

  // 더 간단히 인자와 리턴 타입을 생략 가능
  button.setOnClickListener{
      ...
  }
  ```



## 5.2 자바에서 코틀린 코드 사용하기

### 프로퍼티의 Getter/Setter화

- Getter/Setter의 프로퍼티화의 __역__

- `val`로 선언된 경우 __읽기__만 가능

  ```kotlin
  class Person(val name: String, var address: String, var isAdult: Boolean)
  ```

  ```java
  Person person = new Person("John Doe", "Somewhere", false);

  System.out.println("name: " + person.getName()
                   + " address: " + person.getAddress()
                   + " adult: " + person.isAdult())

  // 실패: 컴파일 오류
  person.setName("Jane Doe");

  // 성공
  person.setAddress("Nowhere");

  // 성공
  person.setAdult(true);
  ```

### 기본 매개변수가 있는 함수

- `@JvmOverloads` 어노테이션을 추가하면 매개변수에 맞게 메서드 or 생성자를 여러벌 생생

  ```kotlin
  class Person @JvmOverloads constructor(
      val name: String, var address: String = "", var isAdult: Boolen = false) {
      @JvmOverloads
      fun doSomething(a: String, b: Int = 0, c: Boolean = false) {
          ...
      }
  }
  ```

  ```java
  Person person1 = new Person("Lorem ipsum");
  Person person2 = new Person("Lorem ipsum", "Somewhere");
  Person person3 = new Person("Lorem ipsum", "Somewhere", true);

  person1.doSomething("foo");
  person1.doSomething("foo", 1);
  person1.doSomething("foo", 1, true);
  ```

### 패키지 단위 함수/변수

- 코틀린에서 패키지 단위로 선언된 함수 or 변수는 자바 코드에서 __파일명을 사용하여 접근 가능__

  ```kotlin
  // Foo.kt
  package com.foo.bar

  const val BAR = "bar"

  fun baz() {
      ...
  }
  ```

  ```java
  String bar = FooKt.bar;
  FooKt.baz();
  ```

- `@JvmName` 어노테이션을 사용하면 파일명 대신 원하는 이름 사용 가능

  ```kotlin
  // Foo.kt
  @file:JvmName("FooUtils")
  ...
  ```

### 동반 객체 및 싱글톤

- 코틀린에서 동반 객체(companion object) 내 선언된 함수나 변수를 클래스 이름만으로 접근

  ```kotlin
  class Foo {
      companion object {
          val BAR = "bar"
          
          fun baz() {
              ...
          }
      }
  }

  val bar = Foo.BAR

  Foo.baz()
  ```

- 자바에서는 `클래스명.Companion` 키워드를 추가하여 접근

- 변수는 Getter 함수를 통해 접근

  ```java
  // 코틀린 프로퍼티의 변환 규칙에 따라 Getter 형태로 변환
  String bar = Foo.Companion.getBAR();

  Foo.Companion.baz();
  ```

- 코틀린에서 사용하는 것과 동일하게 사용하고 싶은 경우, `@JvmField`, `@JvmStatic` 어노테이션을 사용

  ```kotlin
  class Foo {
      companion object {
          @JvmField
          val BAR = "bar"
          
          @JvmStatic
          fun baz() {
              ...
          }
      }
  }
  ```

- `@JvmField` 어노테이션 대신 `const` 키워드를 사용하면 자바 코드의 정적 필드처럼 취급

  ```kotlin
  class Foo {
      companion object {
          const val BAR = "bar"
          
          ...
      }
  }
  ```

- 싱글톤도 동반 객체와 유사하게 사용

- 싱글톤 클래스의 변수 및 함수에 접근은 `INSTANCE` 키워드로

- 동반 객체와 마찬가지로 변수는 Getter 함수를 사용하여 접근

  ```kotlin
  object Foo {
      val BAR = "bar"
      
      fun baz() {
          ...
      }
  }
  ```

  ```java
  String bar = Foo.INSTANCE.getBAR();
  Foo.INSTANCE.baz();
  ```

- 동반 객체와 마찬가지로 변수는 `const` or `@JvmField`, 함수는 `@JvmStatic` 어노테이션을 코틀린처럼 사용 가능

  ```kotlin
  object Foo {
      const val BAR = "bar"
      
      @JvmStatic
      fun baz() {
          ...
      }
  }
  ```

### Checked exception

- 코틀린읜 Checked exception을 검사하지 않음
  즉, 자바의 `throws`와 같은 문법이 존재하지 않음

  ```kotlin
  class Foo {
      fun doSomething() {
          ...
          throw IOException()
      }
  }
  ```

  - 코틀린에서 예외를 발생시키는 간단한 예

- 예외를 처리하려면 `try-catch` 문을 이용

- 하지만, `doSomething()` 함수에서 예외를 발생시킨다는 것이 명시되어 있지 않기 때문에 컴파일 오류 발생

- `@Throws` 어노테이션을 사용하여 자바 쪽에 알려줘야 함

  ```kotlin
  class Foo {
      @Throws(IOException::class)
      fun doSomething() {
          ...
          throw IOException()
      }
  }
  ```

  ​