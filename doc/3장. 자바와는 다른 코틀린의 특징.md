## 3.1 클래스

### `data class`

- `hashCode()`, `equals()` 메서드

  ```java
  public class Person {
    private String name;
    private String address;
    
    ...
  }
  ```

  - 자바에서 객체를 비교하기 위해선 위 두 가지 메서드를 추가로 구현해야 함
  - 클래스에 수정이 있을 경우 위 두 가지 메서드도 신경을 써줘야 함
  - 즉, 개발자에게 부담

- 코틀린의 __데이터 클래스__는 위와 같은 불편함이 해소

  ```kotlin
  data class Person(val name: String, val address: String)
  ```

### `sealed class`

- `enum` 클래스의 확장판

  - `enum` 클래스와 달리 인스턴스를 여러 개 생성 가능
  - `enum` 클래스의 특징을 그대로 가지고 있음 _Effective Java 참고_

- 선언

  ```kotlin
  sealed class MobileApp(val os: String) {
    class Android(os: String, val packageName: String) : MobileApp(os)
    class IOS(os: String, val bundleId: String) : MobileApp(os)
  }
  ```

  - `Android`와 `IOS` 클래스는 `MobileApp`과 같은 파일 안에 있으면 __외부에 정의할 수 있음__

- 사용

  ```kotlin
  fun whoami(app: MobileApp) = when (app) {
    is MobileApp.Android -> println("${app.os} / ${app.packageName}")
    is MobileApp.IOS -> println("${app.os} / ${app.bundleId}")
  }
  ```

  - `sealed class`라면 `else` 구문이 필요 없음
  - `MobileApp`에 수정이 있을 때, 개발자의 실수를 줄일 수 있음 _`whoami()` 메서드에서 컴파일 에러가 남_

### 프로퍼티의 사용자 지정 Getter/Setter

- 클래스 내부에 Getter/Setter를 구현하고 있음

- 사용자 지정 Getter/Setter를 사용하면 개발자가 원하는 방향으로 프로퍼티 제공 가능

- 사용자 지정 Getter/Setter는 프로퍼티 선언과 함께 `get()`, `set(value)`로 선언

- 사용

  ```kotlin
  class Person(val age: Int, val name: String) {
    val adult: Boolean 
      get() = age >= 19
    
    val address: String = ""
      set(value) {
        field = value.substring(0..9)
      }
  }
  ```

  - 위 부분을 `XXXPreferences` 클래스 쪽에 적용할 수 있음

## 3.2 함수

### 명명된 인자

- 함수 인자 순서와 관계없이 전달 가능

- 사용

  ```kotlin
  // 원 그리는 함수
  fun drawCircle(x: Int, y: Int, radius: Int) {
    ...
  }

  // 호출
  drawCircle(10, 5, 25)
  drawCircle(x = 10, y = 5, radius = 25)
  drawCircle(10, 5, radius = 25)
  ```

### 기본 매개변수

- 자바에서는 메서드의 인자를 생략하기 위해 __메서드 오버로딩__ 방식을 사용

  ```java
  void drawCircle(int x, int y) {
    drawCicle(x, y, 25);
  }

  void drawCircle(int x, int y, int radius) {
    ...
  }

  drawCircle(10, 5);
  ```

  - 굉장히 많은 메서드들이 선언될 수 있음

- 코틀린은 메서드 인자에 __기본 값 지정이 가능__

  ```kotlin
  fun drawCircle(x: Int, y: Int, radius: Int = 25) {
    ...
  }

  drawCircle(10, 5)
  ```

### 단일 표현식 표기

- `Unit` 외의 타입을 반환하는 함수는 __단일 표현식__을 사용하여 메서드 정의 가능

  ```kotlin
  fun theAnswerToLifeTheUniverseAndEverything(): Int = 21 * 2

  // 반환 타입 생략도 가능
  fun theAnswerToLifeTheUniverseAndEverything() = 21 * 2
  ```

### 확장 함수

- 코틀린은 클래스 상속 없이 기존 클래스에 새로운 메서드를 추가할 수 있음

- 추가할 대상 클래스를 __리시버 타입__이라 함

- 추가는 `리시버타입.메서드명()` 방식으로 정의

- 정의

  ```kotlin
  // String 클래스에 withPostfix() 메서드 추가
  private fun String.withPostfix(postFix: String) = "$this$postFix"

  // this 키워드로 인스턴스의 확장 함수에 접근 가능
  fun String.withBar() = this.withPostfix("Bar")

  // 호출
  val foo = "Foo"
  val foobar = foo.withBar()
  ```

- 당연한 얘기지만 리서버 타입의 클래스에 `public`으로 정의된 프로퍼티, 메서드에 접근 가능

### 연산자 오버로딩

- 코틀린은 __사용자 정의 타입에 한해__ 연산자 오버로딩을 지원

- 연산자별로 __사전 정의된 메서드를 재정의__하는 방식

- `operator` 키워드를 앞에 추가해야 함

  ```kotlin
  class Volume {
    operator fun unaryPlus() : Volume {
      ...
    }
  }
  ```

- 연산자별 함수

  - 단항 연산자

    | 연산자  | 함수           |
    | :--- | :----------- |
    | +    | `unaryPlus`  |
    | -    | `unaryMinus` |
    | !    | `not`        |
    | ++   | `inc`        |
    | --   | `dec`        |

  - 이항 연산자

    | 연산자  | 함수      |
    | ---- | ------- |
    | +    | `plus`  |
    | -    | `minus` |
    | *    | `times` |
    | /    | `div`   |
    | %    | `rem`   |

  - 비교 연산자

    | 연산자  | 함수          | 참인 경우               |
    | ---- | ----------- | ------------------- |
    | >    | `compareTo` | 반환 값이 0보다 큰 경우      |
    | <    | `compareTo` | 반환 값이 0보다 작은 경우     |
    | >=   | `compareTo` | 반환 값이 0보다 크거나 같은 경우 |
    | <=   | `compareTo` | 반환 값이 0보다 작거나 같은 경우 |
    | ==   | `equals`    | -                   |

    - `equals`를 재정의할 때는 `operator` 키워드를 앞에 추가하지 않음

  - 인덱스 접근 연산자

    | 연산자  | 용도       | 함수    |
    | ---- | -------- | ----- |
    | [ ]  | 값을 읽는 목적 | `get` |
    | [ ]  | 값을 쓰는 목적 | `set` |

  - 복합 할당 연산자

    | 연산자  | 함수            |
    | ---- | ------------- |
    | +=   | `plusAssign`  |
    | -=   | `minusAssgin` |

- 추가 더 많은 내용은 [Kotlin Document](https://kotlinlang.org/docs/reference/operator-overloading.html) 참고

### 중위 표기법 지원

- 아래 조건을 만족하면 중위 표기법을 지원할 수 있음

  - `infix` 키워드를 메서드 선언 앞에 추가
  - 확장 함수 or 멤버 함수면서, __인자가 하나__일 것

- 사용

  ```kotlin
  infix fun Volume.decreaseBy(amount: Int) {
    ...
  }

  // 호출
  val currentVolume = Volume(50, 50)
  currentVolume decreaseBy 20
  ```

## 3.3 람다 표현식

### 자바와 코틀린의 람다 표현식

- 자바

  ```java
  Button button = ...;
  button.setOnClickListener((View v) -> doSomething());
  button.setOnClickListener(v -> doSomething()); // 인자의 타입 생략 가능
  ```

- 코틀린

  ```kotlin
  val button: Button = ...
  button.setOnClickListener({ v: View -> doSomething() })
  button.setOnClickLisetenr({ v -> doSomething() }) // 인자의 타입 생략 가능
  ```

- 자바의 __메서드 참조__를 코틀린은 __멤버 참조__라는 이름으로 지원 _사용법 동일_

  ```kotlin
  fun doSomethingWithView(view: View) {
    ...
  }

  val button: Button = ...
  button.setOnClickListener(::doSomethingWithView)
  ```

  - 코틀린은 __프로퍼티에도 멤버 참조를 지원__

  ```kotlin
  class Person(val name: String, val age: Int) {
    val adult = age > 19
  }

  fun printAdult(people: List<Person>) {
    people
      .filter(Person::adult)
      .forEach {
        println("Name= ${it.name}")
      }
  }
  ```

### 코틀린 람다 표현식의 유용한 기능

- 괄호 외부 선언

  - 람다 표현식 안의 마지막 인자가 함수 타입이라면 __괄호 외부에 선언 가능__

- `_` 키워드

  - 람다 표현식에서 사용하지 않는 인자를 `_`로 표현 가능

- 사용

  ```kotlin
  val dialog = AlertDialog.Builder(this)
    ...
    .setPositiveButton("OK"), { dialog, which -> doOnOkay(which) }
    .setNegativeButton("Cancel") { _, which -> doOnCancel(which) }
  ```

### 인라인 함수

- 람다 표현식으로 들어간 함수__(= 고차함수)__는 컴파일 과정에서 __익명 클래스__로 변환

- 즉, 람다 표현식의 함수를 호출할 때마다 새로운 객체가 생성 _성능에 영향을 줌_

- `inline` 키워드를 사용하면 컴파일 과정에서 코드로 대입 _성능 하락 방지_

  - C++의 그것과 같다고 생각하면 될 듯...?

- 인라인 처리되지 않아야될 항목은 `noinline` 키워드를 추가

- 사용

  ```kotlin
  inline fun doSomething(inlinedBody: () -> Unit, noinline notInlinedBody: () -> Unit) {
    ...
  }
  ```

## 3.4 코틀린의 여타 특징

### 타입 별칭

- __복잡한 형태의 타입을 사용하는 경우__ 표현하려고 했던 의도를 파악하기 힘듦

- `typealias` 키워드를 사용하여 의미 전달에 도움

  ```kotlin
  // 사람 정보를 저장하는 리스트
  typealias PeopleList = List<Person>

  // 특정 태그를 가진 사람의 리스트를 포함하는 맵
  typealias PeopleInMap = Map<String, Person>

  // 사용
  fun sendMessage(people: PersonList) {
    people.forEach {
      // 메세지 전송
    }
  }
  ```

- 함수형 타입에도 적용 가능

  ```kotlin
  // 함수형 타입을 타입 별칭으로 설정
  typealias PersonFilter = (Person) -> Boolean

  fun sendMessage(people: List<Person>, filterFunc: (Person) -> Boolean) {
    people
      .filter(filerFunc)
      .forEach {
        // 메세지 전송
      }
  }
  ```

- 타입 별칭은 성능에 영향 없음

### 분해 선언

- 어떤 객체의 일부 속성만 가져오는 경우 자바는 일일히 가져와야 함

  ```java
  class Person {
    ...
    public int getAge() { ... }
    public String getName() { ... }
    ...
  }

  Person person = ...;

  int ageOfPerson = person.getAge();
  String nameOfPerson = person.getName();
  ```

- 코틀린의 경우 __분해 선언__을 통해 위와 동일한 기능을 하는 코드를 작성할 수 있음

  ```kotlin
  data class Person(val age: Int, val name: String, ...)

  val person: Person = ...

  val (ageOfPerson, nameOfPerson) = person
  ```

- 룰

  - 분해 선언을 사용한 부분이 컴파일 된 결과는 아래와 같음

    ```kotlin
    val ageOfPerson: Int = person.component1()
    val nameOfPerson: String = person.component2()
    ```

  - 분해 선언을 사용하기 위해선 프로퍼티 수 만큼  `componentN()`  메서드가 있어야 함

  - 사용자 정의 클래스에 분해 선언 적용

    ```kotlin
    class Person(val age: Int val name: String) {
      operator fun component1() = this.age
      operator fun component2() = this.name
    }
    ```

    - 불편한데...?

- 기본 제공되는 클래스들

  - `data class`
  - `kotlin.Pair`
  - `kotlin.Triple`
  - `kotlin.collections.Map.Entry`

- 반복문에서도 사용 가능

  ```kotlin
  val cities: Map<String, String> = ...

  for ((cityCode, name) in cities) {
    System.out.println("$cityCode=$name")
  }
  ```

- 람다 표현식에서도 사용 가능

  ```kotlin
  cities.forEach { cityCode, name ->
    System.out.println("$cityCode=$name")
  }
  ```

  ​