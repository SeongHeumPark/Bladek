## 6.1 RxAndroid 소개

- 안드로이드 개발 중 가장 어려움을 겪는 문제 중 하나는 복잡한 스레드 사용
- 스레드 사용으로 발생하는 문제
  - 비동기 처리 및 에러 핸들링
  - 디버깅 문제
  - 2개의 비동기 처리 후 결과를 하나로 합성하는 작업
  - 이벤트 중복 실행
- RxAndroid 장점
  - 간단한 코드로 복잡한 병행 프로그래밍을 할 수 있음
  - 비동기 구조에서 에러를 다루기 쉬움
  - 함수형 프로그래밍 기법도 부분적 적용 가능

## 6.2 Rx Android 기본

- RxAndroid의 기본 구성 요소는 RxJava와 같음

- 예제

  ```java
  // 1. Observable 생성.
  Observable.create()
    // 2. 구독자 이용.
    .subscribe();

    // 3. 스케줄러 이용.
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
  ```

- RxAndroid에서 제공하는 스케줄러

  | 스케줄러 이름                         | 설명                        |
  | ------------------------------- | ------------------------- |
  | AndroidSchedulers.mainThread()  | 안드로이드의 UI 스레드에서 동작하는 스케줄러 |
  | HandlerSchedulers.from(handler) | 특정 핸들러에 의존하여 동작하는 스케줄러    |

### 6.2.2 제어 흐름

- 예제

  ```java
  Iterable<String> samples = Arrays.asList(
    "banana", "orange", "apple", "apple mango", "melon", "watermelon");

  Observable.fromIterable(samples)
    .filter(s -> s.contains("apple"))
    .first("Not Found")
    .subscribe(s -> Log.d(TAG, s));
  ```

  - 기존 자바의 `for` 문을 `filter()` 함수와 `first()` 함수를 이용하여 대체함

### 6.2.3 RxLifecycle 라이브러리

- 안드로이드의 `Activity`와 `Fragment`의 라이프 사이클을 RxJava에서 사용할 수 있게 함

- 안드로이드 UI와 라이프 사이클을 대체 X
  __구독할 때 발생할 수 있는 메모리 누수를 방지하기 위해 사용__

- 컴포넌트 목록: p.210

- 예제

  ```java
  public class MainActivity extends RxAppCompatActivity {
    private static final String TAG = MainActivity.class.getSimpleName();

    @BindView(R.id.text_view)
    TextView textView;

    private Unbinder unbinder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);

      unbinder = ButterKnife.bind(this);

      Observable.just("Hello. rx world!")
        .compose(bindToLifecycle())
        .subscribe(textView::setText);
    }

    @Override
    protected void onDestroy() {
      super.onDestroy();

      if (unbinder != null) {
        unbinder.unbind();
      }
    }
  }
  ```

  - `compose()` 함수로 라이프 사이클을 관리함 (`MainActivity`가 종료되면 자동으로 해제)
  - 직접 `dispose()` 함수를 호출해 라이프 사이클을 관리할 수 있음 (각각 장단이 있음 > 상황에 맞게 사용)

### 6.2.4 UI 이벤트 처리

#### 이벤트 리스너

- 예제

  ```java
  @Override
  public void onActivityCreated(@Nullable Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);

    getClickEventObservable()
      .map(s -> "clicked")
      .subscribe(getObserver());
  }

  private Observable<View> getClickEventObservable() {
    return Observable.create(o -> button.setOnClickListener(o::onNext));
  }

  private DisposableObserver<? super String> getObserver() {
    return new DisposableObserver<String>() {
      @Override
      public void onNext(String s) {
        Log.d(TAG, s);
      }

      @Override
      public void onError(Throwable e) {
        Log.e(TAG, e.getMessage());
      }

      @Override
      public void onComplete() {
        Log.d(TAG, "complete");
      }
    };
  }
  ```

- __액티비티 중복 실행 문제 해결 코드__

  ```java
  @Override
  public void onActivityCreated(@Nullable Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    
    mDisposable = getObservable()
      .debounce(1000, TimeUnit.MILLISECONDS)
      .observeOn(AndroidSchedulers.mainThread())
      .subscribe(s -> {
        SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss", Locale.KOREA);
        String time = sdf.format(Calendar.getInstance().getTime());
        mDisplay.setText("Clicked : " + time.toString());
      });
  }
  ```

## 6.3 RxAndroid 활용

### 6.3.1 리액티브 `RecyclerView`

- 디바이스에 설치된 앱 목록을 가져와 리스트로 보여주는 앱 작성

- 활용 부분

  ```java
  class MyViewHolder extends RecyclerView.ViewHolder {
    // ...
    
    Observable<RecyclerItem> getClickObserver(RecyclerItem item) {
      return Observable.create(e -> itemView.setOnClickListener(
        view -> e.onNext(item)));
    }
  }
  ```

  ```java
  class RecyclerViewAdapter 
    extends RecyclerView.Adpater<RecyclerViewAdapter.MyViewHolder> {
    // ...
    
    // 아이템을 클릭하면 실행되는 이벤트를 Observable Fragement에서 최종 처리
    private publishSubject<RecyclerItem> publishSubject;
    
    RecyclerViewAdapter() {
      this.publicshSubject = PublishSubject.create();
    }
    
    // ...
    
    @Override
    public void onBindViewHolder(MyViewHolder holder, int position) {
      // ...
      holder.getClickObserver(item).subscribe(publishSubject);
    }
    
    // ...
    
    public PublishSubject<RcyclerItem> getItemPublishSubject() {
      return publishSubject;
    }
  }
  ```

  ```java
  public class RecyclerViewFragment extends Fragment {
    // ...
    
    private RecyclerViewAdapter adapter;
    
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
      // ...
      
      adapter = new RecyclerViewAdpater();
      recyclerView.setAdapter(adapter);
      adapter
        .getItemPublishSubject()
        .subscribe(s -> toast(s.getTitle()));
    }
    
    @Override
    public void onStart() {
      // ...
      
      getItemObservable()
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(item -> {
          adapter.updateItems(item);
          adapter.notifyDataSetChanged();
        })
    }
  }
  ```

### 6.3.2 안드로이드 스레드를 대체하는 RxAndroid

- 당연한 얘기지만, 처리하는데 오래 걸리는 작업(데이터 전송, 파일 입출력 등)은 별도의 스레드로 관리해야 함
- 안드로이드에서 뷰와 뷰 그룹은 오직 __UI 스레드__에서만 처리되도록 함
- 안드로이드는 멀티 스레드 환경에 대응하기 위해 `Looper`, `Handler`, `AsyncTask` 등을 지원

#### `AsyncTask` 클래스에 RxAndroid 적용하기

- 적용하기보단 대체하기가 맞는 것 같음

- `AsyncTask`는 아래와 같은 단점이 있음

  - 오직 한 번 만 실행 == 재사용 불가능
  - 액티비티 종료를 명시해야만 종료되므로 메모리 누수 발생
  - `AsyncTask`는 반드시 __UI 스레드 위__에서 불러야 함

- 대체 부분

  ```java
  private void initRxAsync() {
    Observable.just("Hello", "rx", "world")
      .reduce((x, y) -> x + " " + y)
      .observeOn(AndroidSchedulers.mainThread())
      .subscribe(
        textView::setText,
        e -> Log.e(TAG, e.getMessage()),
        () -> Log.i(TAG, "done"));
  }
  ```

- 대체 표

  | `AsyncTask`        | RxAndroid                         |
  | ------------------ | --------------------------------- |
  | `execute()`        | `subscribe()`                     |
  | `doInBackground()` | 리액티브 연산자와 함께 사용하는 `onSubscribe()` |
  | `onPostExecuted()` | observer                          |

#### RxAndroid를 이용하여 TimerTask 대체하기

- 두 가지 방법 소개

  - `interval()` 함수 활용
  - `repeatWhen()`, `delay()` 함수 활용

- 대체 부분

  ```java
  // interval() 함수 활용
  Observable<String> ob = Observable.interval(3, TimeUnit.SECONDS)
    .flatMap(o -> Observable.just("polling #1"));

  ob.subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(this::log);

  // repeatWhen(), delay() 함수 활용
  Observable<String> ob2 = Observable.just("polling #2")
    .repeatWhern(o -> o.delay(3, TimeUnit.SECONDS));

  ob2.subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(this::log);
  ```

### 6.3.3. REST API를 활용한 네트워크 프로그래밍

#### Volley 라이브러리 활용

#### Retrofit2 + OkHttp 활용

## 6.4 메모리 누수

- `Observable`은 안드로이드의 컨텍스틑 복사하여 유지함

### 6.4.1 해결책 1: `Disposable` 인터페이스를 이용하여 명시적으로 자원 해제

- `onCreate()`에서 `subscribe()` 함수를 호출하면 `onDestory()`에서 __메모리 참조 해제__
- `onResume()`에서 `subscribe()` 함수를 호출하면 `onPause()`에서 __메모리 참조 해제__

### 6.4.2 해결책 2: RxLifecycle 라이브러리 이용

- `RxAppCompatActivity` 클래스를 상속받도록 변경
- `compose()` 함수를 사용하여 RxLifecycle 라이브러리 적용
- 종료 시점을 커스텀할 수 있음 _p.258_

### 6.4.3 해결책 3: `CompositeDisposable` 클래스 이용

- `CompositerDisposable` 클래스를 이용하면 생성된 모든 `Observable`을

  안드로이드 라이프 사이클에 맞춰 한 번에 모두 해제 가능

- 해결책 1의 연장선