## 2.1 기본 자료형

### 타입

- 코틀린은 Primitive 타입이 없음

- 컴파일 단계를 거치면서 가장 효율적인 타입으로 변환

  - `val` __또는__ `var`__인 경우:__ Primitive 타입
  - __컬렉션인 경우:__ Wrapper 타입

- 자바의 Primitive, Wrapper 타입 외의 자료형은 __플랫폼 타입__으로 처리

  | Java                   | Kotlin               |
  | ---------------------- | -------------------- |
  | java.lang.Annotation   | kotlin.Annotation!   |
  | java.lang.CharSequence | kotlin.CharSequence! |
  | java.lang.Cloneable    | kotlin.Cloneable!    |

  _자세한 내용은 p.12 참고_

### 숫자

- 숫자를 표현하는 모든 자료형은 `Number` 클래스를 상속

- 리터럴 표기 중 `Long`은 `I`와 혼동을 방지하기 위해 `L`을 사용
  _지금 자바 쓸 때_ `L`_로 하고있는데..?_

- 비트 연산자는 자바에 비해 좀 더 직관적

  | Java | Kotlin | 의미                    |
  | ---- | ------ | --------------------- |
  | &    | and    | 비트 연산 AND             |
  | \|   | or     | 비트 연산 OR              |
  | ^    | xor    | 비트 연산 XOR             |
  | ~    | inv    | 비트 연산 NOT             |
  | <<   | shl    | 왼쪽으로 시프트 (부호 시프트 유지)  |
  | >>   | shr    | 오른쪽으로 시프트 (부호 시프트 유지) |
  | >>>  | ushr   | 오른쪽으로 시프트 (부호 시프트 무시) |

### 문자

- 코틀린은 문자에 숫자를 대입할 경우 컴파일 에러 발생

  ```kotlin
  // 컴파일 에러
  val c : Char = 65

  // 성공
  val c : Char = 'A'
  ```

  - `Char` 타입으로 변환하려거든 `toChar()`를 사용할 것

### 논리

- 자바와 동일

### 문자열

- 자바 문자열과 특징, 표현, 사용법이 유사

  ```kotlin
  val foo : String = "Lorem ipsum"
  ```

- 문자 접근은 `charAt()` 대신 `get()`과 `[]`를 사용

  ```kotlin
  val foo : String = "Lorem ipsum"

  // ch1에 'm' 할당
  val ch1 : Char = foo.get(4)

  // ch2에 'i' 할당
  val ch2 : Char = foo[6]
  ```

- Formatted String은 자바와 동일하게 `String.format()` 사용

- 코틀린에서 제공하는 __문자열 템플릿__ 기능을 사용하면 `String.format()`과 달리 직접 인자를 대입할 수 있음

  ```kotlin
  val length : Int = 3000
  val lengthText : String = "Length: $length meters"
  ```

  - __값__이나 __변수__를 대입

  ```kotlin
  val text : String = "Lorem ipsum"
  val lengthText : String = "TextLength: ${text.legnth}"
  ```

  - __표현식__을 대입

  ```kotlin
  val price : Int = 1000
  val priceText : String = "Price: ${'$'}$price"
  ```

  - `'$'`__문자__ 대입

### 배열

- 코틀린에서 배열은 __타입 인자를 갖는__ `Array` __클래스__로 표현

  ```kotlin
  val words : Array<String> = arrayOf("Lorem", "ipsum", "dolor", "sit")
  ```

  - `arrayOf()`는 표준 라이브러리 함수

- Primitive 타입 배열에 상응하는 코틀린 클래스를 제공

  | Java     | Kotlin             |
  | -------- | ------------------ |
  | byte[]   | kotlin.ByteArray   |
  | double[] | kotlin.DoubleArray |
  | float[]  | kotlin.FloatArray  |
  | int[]    | kotlin.IntArray    |
  | long[]   | kotlin.LongArray   |
  | short[]  | kotlin.ShortArray  |

- 코틀린 Primitive/Wrapper 타입 배열을 생성하는 함수도 표준 라이브러리에 포함되어 있음

  ```kotlin
  // Primitive 타입 int 배열을 선언하는 예
  val intArr : IntArray = intArrayOf(1, 2, 3, 4, 5)

  // Wrapper 타입 Int 배열을 선언하는 예
  val intArr : Array<Int> = arrayOf(1, 2, 3, 4, 5)
  ```

- 코틀린 배열을 __자바로 작성된 함수의 인자 or 가변인자__로 받을 경우 __스프레드시트 연산자__(`*`)를 사용

  ```java
  public void foo(int[] arr) {
    // ...
  }

  public void bar(String... args) {
    // ...
  }
  ```

  ```kotlin
  // foo() 메서드 호출
  val intArr : IntArray = intArrayOf(1, 2, 3, 4, 5)
  foo(*intArr)

  // bar() 메서드 호출
  val stringArr : Array<String> = arrayOf("Lorem", "ipsum", "dolor", "sit")
  bar(*stringArr)
  ```

- __코틀린으로 작성된 함수가 가변인자__로 받을 경우에도 마찬가지

  ```kotlin
  fun bar(vararg args: String) {
    // ...
  }

  val stringArr : Array<String> = arrayOf("Lorem", "ipsum", "dolor", "sit")
  bar(*stringArr)
  ```

## 2.2 컬렉션

- JVM 기반 코틀린의 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용

- 단, 타입 별칭을 사용하여 컬렉션 내에 다른 클래스와 일관성을 유지

  | 원본 타입                   | 타입 별칭                            |
  | ----------------------- | -------------------------------- |
  | java.util.ArrayList     | kotlin.collections.ArrayList     |
  | java.util.HashMap       | kotlin.collections.HashMap       |
  | java.util.HashSet       | kotlin.collections.HashSet       |
  | java.util.LinkedHashMap | kotlin.collections.LinkedHashMap |
  | java.util.LinkedHashSet | kotlin.collections.LinkedHashSet |
  | java.util.RandomAccess  | kotlin.collections.RandomAccess  |
  | java.util.SortedSet     | kotlin.collections.SortedSet     |
  | java.util.TreeSet       | kotlin.collections.TreeSet       |

- 코틀린에서는 컬렉션 내 자료의 수정 가능 여부에 따라 컬렉션의 종류를 구분
  새로운 타입 선언 X, __인터페이스를 통해 사용 가능한 함수를 제한__하는 방식

  | 자료구조 | 수정 불가                   | 수정 가능                          |
  | ---- | ----------------------- | ------------------------------ |
  | List | kotlin.collections.List | kotlin.collections.MutableList |
  | Map  | kotlin.collections.Map  | kotlin.collections.MutableMap  |
  | Set  | kotlin.collections.Set  | kotlin.collections.MutableSet  |

- __주의사항__

  - 코틀린에서 컬렉션의 자료 수정 가능 여부를 제한하는 것은 자바에서 적용되지 않음

    ```kotlin
    fun immutable() : List<String> {
      // ...
    }

    fun mutable() : MutableList<String> {
      // ...
    }
    ```

    ```java
    List<String> immutableList = immutable();
    List<String> mutableList = mutable();
    ```

    - 둘 호출 모두 수정할 수 있는 `java.util.List`로 변환됨

  - 자바와 코틀린을 혼용하는 경우, 위와 같은 상황에서 인터페이스에만 의존하지 않도록 유의해야 함

- 예제

  ```kotlin
  // immutable list
  val immutableList : List<String> = listOf("Lorem", "ipsum", "dolor", "sit")
  immutableList.add("amet") // 에러

  // mutable list
  val mutableList : MutableList<String> = arrayListOf("Lorem", "ipsum", "dolor", "sit")
  mutableList.add("amet")

  // mutable list to immutable list
  val immutableList2 : List<String> = mutableList
  imumutableList.add("amet") // 에러

  // map
  val map : HashMap<String, Int> = mapOf("A" to 65, "B" to 66)
  ```

  - `Map`의 경우 `Pair("A", 65)` 대신 `"A" to 65`로 나타낼 수 있음

## 2.3 클래스 및 인터페이스

### 클래스와 인터페이스의 선언 및 인스턴스 생성

- 클래스와 인터페이스를 선언하는 방법은 자바와 유사

- 다만 __접근 제한자__에서 차이가 남

  ```java
  // class
  public class Coo {
  }

  // interface
  public interface Ioo {
  }
  ```

  ```kotlin
  // class
  class Coo {
  }

  class Coo

  // interface
  interface Ioo {
  }

  interface Ioo
  ```

  - 코틀린은 접근 제한자가 없으면 `public`으로 간주
  - 몸체가 없는 클래스/인터페이스 선언 가능

- 코틀린은 인스턴스 생성을 위해서 `new` 키워드를 사용하지 않아도 됨

  ```kotlin
  val coo : Coo = Coo()
  ```

- 추상 클래스/인터페이스의 인스턴스 생성 또한 자바랑 유사함

  ```kotlin
  // 추상 클래스
  abstract class Foo {
    abstract fun bar()
  }

  val foo = object: Foo() {
    
    override fun bar() {
    }
  }

  // 인터페이스
  interface Foo {
    abstract fun bar()
  }

  val foo = object: Foo() {
    
    override fun bar() {
    }
  }
  ```

### 프로퍼티

- 자바는 값에 접근하기 위한 Getter/Setter 메서드를 추가해야 하므로 코드의 양이 불필요하게 늘어났음

### 접근 제한자

### 생성자

### 함수

### 상속 및 인터페이스 구현

### `this`

### 정적 필드 및 메서드

### 싱글톤

### `enum` 클래스

### 어노테이션 클래스

