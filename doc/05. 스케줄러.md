## 5.1 스케줄러 개념 배우기

- __비동기 동작을 수행하기 위해__ 스케줄러를 사용

- 스케줄러는 __스레드를 지정할 수 있음__

- 예제

  ```java
  String[] args = { "1-S", "2-T", "3-P" };
  Observable<String> source = Observable.fromArray(objs)
    .doOnNext(data -> Log.v("Original data = " + data))
    .subscribeOn(Schedulers.newThread())
    .observeOn(Schedulers.newThread())
    .map(Shape::flip);
  source.subscribe(Log::i);
  CommonUtils.sleep(500);
  ```

  - `doOnNext()`: 원래 데이터 값을 확인
  - `subscribeOn()`: `subscribe()` 함수를 호출하여 구독할 때 실행되는 스레드 지정
  - `observeOn()`: `Observable`에서 생성한 데이터 흐름이 처리될 때 동작하는 스레드 지정

- __핵심__은 __데이터 흐름이 발생하는 스레드__와 __처리된 결과를 구독자에게 전달하는 스레드__를 __분리__할 수 있음

- 정리

  - p.175 참고

## 5.2 스케줄러의 종류

- 스케줄러 변경이 쉬움
- `Schedulers` 클래스의 __정적 팩토리 메서드__로 생성
- __추천하는 스케줄러__는 크게 __세 가지__ (나머지는 특수한 상황에서 적용하길 __권장__)
  - __계산 스케줄러__
  - __IO 스케줄러__
  - __트램펄린 스케줄러__

### 5.2.1 뉴 스레드 스케줄러

- 새로운 스레드 생성

- `Schedulers.newThread()`를 인자로 넣으면 됨

- 적극적으로 추천하진 않음
  __why?__ 활용도가 높은 __계산 스케줄러__와 __IO 스케줄러__와 같은 스케줄러를 제공하기 때문

- 예제

  ```java
  String[] orgs = { "1", "3", "5" };
  Observable.fromArray(orgs)
    .doOnNext(data -> Log.v("Original data : " + data))
    .map(data -> "<<" + data + ">>")
    .subscribeOn(Schedulers.newThread())
    .subscribe(Log::i);
  CommonUtils.sleep(500);

  Observable.fromArray(orgs)
    .doOnNext(data -> Log.v("Original data : " + data))
    .map(data -> "##" + data + "##")
    .subscribeOn(Schedulers.newThread())
    .subscribe(Log::i);
  CommonUtils.sleep(500);
  ```

- 결과

  ```
  RxNewThreadScheduler-1 | Orginal data : 1
  RxNewThreadScheduler-1 | value = <<1>>
  RxNewThreadScheduler-1 | Orginal data : 3
  RxNewThreadScheduler-1 | value = <<3>>
  RxNewThreadScheduler-1 | Orginal data : 5
  RxNewThreadScheduler-1 | value = <<5>>
  RxNewThreadScheduler-2 | Orginal data : 1
  RxNewThreadScheduler-2 | value = ##1##
  RxNewThreadScheduler-2 | Orginal data : 3
  RxNewThreadScheduler-2 | value = ##3##
  RxNewThreadScheduler-2 | Orginal data : 5
  RxNewThreadScheduler-2 | value = ##5##
  ```

### 5.2.2 계산 스케줄러

- __CPU에 대응하는__ 계산용 스케줄러 (__계산__ 작업을 할 때는 __대기 시간 없이__ 빠르게 결과를 도출하는 것이 중요)

- 내부적으로 __스레드 풀__을 생성 (스레드 수 == 프로세스 수)

- 예제

  ```java
  String[] orgs = { "1", "3", "5" };
  Observable<String> source = Observable.fromArray(orgs)
    .zipWith(Observable.interval(100L, TimeUnit.MIILISECONDS), (a, b) -> a);

  // 구독 #1
  source.map(item -> "<<" + item + ">>")
    .subscribeOn(Schedulers.computation())
    .subscribe(Log::i);

  // 구독 #2
  source.map(item -> "##" + item + "##")
    .subscribeOn(Schedulers.somputation())
    .subscribe(Log::i);
  CommonUtils.sleep(1000);
  ```

- 결과

  ```
  RxComputationThreadPool-3 | value = <<1>>
  RxComputationThreadPool-4 | value = ##1##
  RxComputationThreadPool-3 | value = <<3>>
  RxComputationThreadPool-4 | value = ##3##
  RxComputationThreadPool-3 | value = <<5>>
  RxComputationThreadPool-4 | value = ##5##
  ```

  or

  ```
  RxComputationThreadPool-3 | value = <<1>>
  RxComputationThreadPool-3 | value = ##1##
  RxComputationThreadPool-3 | value = <<3>>
  RxComputationThreadPool-3 | value = ##3##
  RxComputationThreadPool-3 | value = <<5>>
  RxComputationThreadPool-3 | value = ##5##
  ```

  - 첫 번째와 두 번째 구독의 __동시성 이슈__
    __why?__ [라운드 로빈](https://ko.wikipedia.org/wiki/%EB%9D%BC%EC%9A%B4%EB%93%9C_%EB%A1%9C%EB%B9%88_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81) 방식의 스레드 풀 운용에서 변수 `n++`가 __atomic__하지 않아 발생

### 5.2.3 IO 스케줄러

- __네트워크 요청 처리__, 각종(파일, DB 등) __입/출력__ 작업을 위한 스케줄러

- 필요할 때마다 스레드를 계속 생성

- 예제

  ```java
  String root = "C:\\";
  File[] files = new File(root).listFiles();
  Observable<String> source = Observable.fromArray(files)
    .filter(f -> !f.isDirectory())
    .map(f -> f.getAbsolutePath())
    .subscribeOn(Schedulers.io());

  source.subscribe(Log::i);
  CommonUtils.sleep(500);
  ```

- 결과

  ```
  RxCachedThreadScheduler-1 | value = c:\bootmgr
  RxCachedThreadScheduler-1 | value = c:\BOOTNXT
  RxCachedThreadScheduler-1 | value = c:\HaxLogs.txt
  RxCachedThreadScheduler-1 | value = c:\hidefil.sys
  RxCachedThreadScheduler-1 | value = c:\pagefile.sys
  RxCachedThreadScheduler-1 | value = c:\swapfile.sys
  RxCachedThreadScheduler-1 | value = c:\TEST.txt
  ```

### 5.2.4 트램펄린 스케줄러

- 새로운 스레드 생성 X, __무한한 크기의 Queue__를 생성

- 예제

  ```java
  String[] orgs = { "1", "3", "5" };
  Observable<String> source = Observable.fromArray(orgs);

  source.subscribeOn(Schedulers.trampoline())
    .map(data -> "<<" + data + ">>")
    .subscribe(Log::i);

  source.subscribeOn(Schedulers.trampoline())
    .map(data -> "##" + data + "##")
    .subscribe(Log::i);
  CommonUtils.sleep(500);

  ```

- 결과

  ```
  main | value = <<1>>
  main | value = <<3>>
  main | value = <<5>>
  main | value = ##1##
  main | value = ##3##
  main | value = ##5##
  ```

### 5.2.5 싱글 스레드 스케줄러

- 단일 스레드를 __별도로 생성__

- __구독 작업__ 처리

- 예제

  ```java
  Observable<Integer> numbers = Observable.range(100, 5);
  Observable<String> chars = Observable.range(0, 5)
    .map(CommonUtils.numberToAlphabet);

  numbers.subscribeOn(Schedulers.single())
    .subscribe(Log::i);
  chars.subscribeOn(Schedulers.single())
    .subscribe(Log::i);
  CommonUtils.sleep(500);
  ```

- 결과

  ```
  RxSingleScheduler-1 | value = 100
  RxSingleScheduler-1 | value = 101
  RxSingleScheduler-1 | value = 102
  RxSingleScheduler-1 | value = 103
  RxSingleScheduler-1 | value = 104
  RxSingleScheduler-1 | value = A
  RxSingleScheduler-1 | value = B
  RxSingleScheduler-1 | value = C
  RxSingleScheduler-1 | value = D
  RxSingleScheduler-1 | value = E
  ```

### 5.2.6 Excutor 변환 스케줄러

- 자바에서는 `Executor`를 변환하여 스케줄러를 생성할 수 있음

- 하지만, 동작 방식이 다르므로 추천하지 않음

- 기존 사용하던 `Executor` 클래스를 __재사용__할 때만 __한정적 활용__

- 예제

  ```java
  final int THREAD_NUM = 10;

  String[] data = { "1", "3", "5" };
  Observable<String> source = Observable.fromArray(data);
  Executor executor = Executors.newFixedThreadPool(THREAD_NUM);

  source.subscribeOn(Schedulers.from(executor))
    .subscribe(Log::i);
  source.subscribeOn(Schedulers.from(executor))
    .subscribe(Log::i);
  CommonUtils.sleep(500);

  ```

- 결과

  ```
  pool-1-thread-1 | value = 1
  pool-1-thread-1 | value = 3
  pool-1-thread-1 | value = 5
  pool-1-thread-2 | value = 1
  pool-1-thread-2 | value = 3
  pool-1-thread-2 | value = 5
  ```

## 5.3 스케줄러를 활용하여 콜백 지옥 벗어나기

- A URL을 HTTP GET으로 결과를 받고 난후 B URL을 HTTP GET으로 결과를 받는 코드를 자바로 작성

  ```java
  public void run() {
    Request request = new Requeset.Builder()
      .url(A)
      .build();
    client.newCall(request).enqueue(new Callback() {
      // ...
      
      @Override
      public void onResponse(Call call, Response response) throws IOException {
        Log.i(response.body().string());
        
        Request request = new Request.Builder()
          .url(B)
          .build();
        clinet.newCall(request).enqueue(new Callback() {
          // ...
          
          @Override
          public void onResponse(Call call, Response response) throws IOException {
            // ..
          }
        });
      }
    });
  }
  ```

- RxJava 스케줄러를 활용한 URL 호출

  ```java
  Observable<String> source = Observable.just(A)
    .subscribeOn(Schedulers.io())
    .map(OkHttpHelper::get)
    .concatWith(Observable.just(B)
      .map(OkHttpHelper::get));
  source.subscribe(Log::it);
  ```

- __RxJava 스케줄러__를 이용할 때 __장점__

  - __선언적 동시성__: 순수한 비지니스 로직과 비동기 동작을 위한 스레드 부분을 구별할 수 있음
  - __가독성__: 정상적인 로직과 향후 예외 처리 부분을 깔끔하게 분리

- 성능 업그레이드

  ```java
  Observable<String> first = Observable.just(A)
    .subscribeOn(Schedulers.io())
    .map(OkHttpHelper::get);

  Observable<String> second = Observable.just(b)
    .subscribeOn(Schedulers.io())
    .map(OkHttpHelper::get);

  Observable<String> source = 
    Observable.zip(first, second, (a, b) -> ("\n>> " + a + "\n>> " + b);
  source.subscribe(Log::it);
  ```

- 성능 향상 뿐만 아니라 프로그램의 효율성도 향상시킬 수 있음

## `observableOn()` 함수의 활용

- RxJava의 __핵심__ = __제공되는 스케줄러의 종류를 선택__한 후 `subscribeOn()` 함수, `observableOn()` 함수를 __호출__

![schedulers](images/schedulers.png)

- `subscribeOn()` 함수는 한 번 호출했을 때 결정한 스레드로 __고정__
- `observableOn()` 함수는 여러 번 호출 가능하며 호출 다음부터 스레드 __변경 가능__

