## 5.1 스케줄러 개념 배우기

- __비동기 동작을 수행하기 위해__ 스케줄러를 사용

- 스케줄러는 __스레드를 지정할 수 있음__

- 예제

  ```java
  String[] args = { "1-S", "2-T", "3-P" };
  Observable<String> source = Observable.fromArray(objs)
    .doOnNext(data -> Log.v("Original data = " + data))
    .subscribeOn(Schedulers.newThread())
    .observeOn(Schedulers.newThread())
    .map(Shape::flip);
  source.subscribe(Log::i);
  CommonUtils.sleep(500);
  ```

  - `doOnNext()`: 원래 데이터 값을 확인
  - `subscribeOn()`: `subscribe()` 함수를 호출하여 구독할 때 실행되는 스레드 지정
  - `observeOn()`: `Observable`에서 생성한 데이터 흐름이 처리될 때 동작하는 스레드 지정

- __핵심__은 __데이터 흐름이 발생하는 스레드__와 __처리된 결과를 구독자에게 전달하는 스레드__를 __분리__할 수 있음

- 정리

  - p.175 참고

## 5.2 스케줄러의 종류

- 스케줄러 변경이 쉬움
- `Schedulers` 클래스의 __정적 팩토리 메서드__로 생성
- __추천하는 스케줄러__는 크게 __세 가지__ (나머지는 특수한 상황에서 적용하길 __권장__)
  - __계산 스케줄러__
  - __IO 스케줄러__
  - __트램펄린 스케줄러__

### 5.2.1 뉴 스레드 스케줄러

- 새로운 스레드 생성

- `Schedulers.newThread()`를 인자로 넣으면 됨

- 적극적으로 추천하진 않음
  __why?__ 활용도가 높은 __계산 스케줄러__와 __IO 스케줄러__와 같은 스케줄러를 제공하기 때문

- 예제

  ```java
  String[] orgs = { "1", "3", "5" };
  Observable.fromArray(orgs)
    .doOnNext(data -> Log.v("Original data : " + data))
    .map(data -> "<<" + data + ">>")
    .subscribeOn(Schedulers.newThread())
    .subscribe(Log::i);
  CommonUtils.sleep(500);

  Observable.fromArray(orgs)
    .doOnNext(data -> Log.v("Original data : " + data))
    .map(data -> "##" + data + "##")
    .subscribeOn(Schedulers.newThread())
    .subscribe(Log::i);
  CommonUtils.sleep(500);
  ```

- 결과

  ```
  RxNewThreadScheduler-1 | Orginal data : 1
  RxNewThreadScheduler-1 | value = <<1>>
  RxNewThreadScheduler-1 | Orginal data : 3
  RxNewThreadScheduler-1 | value = <<3>>
  RxNewThreadScheduler-1 | Orginal data : 5
  RxNewThreadScheduler-1 | value = <<5>>
  RxNewThreadScheduler-2 | Orginal data : 1
  RxNewThreadScheduler-2 | value = ##1##
  RxNewThreadScheduler-2 | Orginal data : 3
  RxNewThreadScheduler-2 | value = ##3##
  RxNewThreadScheduler-2 | Orginal data : 5
  RxNewThreadScheduler-2 | value = ##5##
  ```

### 5.2.2 계산 스케줄러

- __CPU에 대응하는__ 계산용 스케줄러 (__계산__ 작업을 할 때는 __대기 시간 없이__ 빠르게 결과를 도출하는 것이 중요)

- 내부적으로 __스레드 풀__을 생성 (스레드 수 == 프로세스 수)

- 예제

  ```java
  String[] orgs = { "1", "3", "5" };
  Observable<String> source = Observable.fromArray(orgs)
    .zipWith(Observable.interval(100L, TimeUnit.MIILISECONDS), (a, b) -> a);

  // 구독 #1
  source.map(item -> "<<" + item + ">>")
    .subscribeOn(Schedulers.computation())
    .subscribe(Log::i);

  // 구독 #2
  source.map(item -> "##" + item + "##")
    .subscribeOn(Schedulers.somputation())
    .subscribe(Log::i);
  CommonUtils.sleep(1000);
  ```

- 결과

  ```
  RxComputationThreadPool-3 | value = <<1>>
  RxComputationThreadPool-4 | value = ##1##
  RxComputationThreadPool-3 | value = <<3>>
  RxComputationThreadPool-4 | value = ##3##
  RxComputationThreadPool-3 | value = <<5>>
  RxComputationThreadPool-4 | value = ##5##
  ```

  or

  ```
  RxComputationThreadPool-3 | value = <<1>>
  RxComputationThreadPool-3 | value = ##1##
  RxComputationThreadPool-3 | value = <<3>>
  RxComputationThreadPool-3 | value = ##3##
  RxComputationThreadPool-3 | value = <<5>>
  RxComputationThreadPool-3 | value = ##5##
  ```

  - 첫 번째와 두 번째 구독의 __동시성 이슈__
    __why?__ [라운드 로빈]() 방식의 스레드 풀 운용에서 변수 `n++`가 __atomic__하지 않아 발생

### 5.2.3 IO 스케줄러

- __네트워크 요청 처리__, 각종(파일, DB 등) __입/출력__ 작업을 위한 스케줄러

- 필요할 때마다 스레드를 계속 생성

- 예제

  ```java
  String root = "C:\\";
  File[] files = new File(root).listFiles();
  Observable<String> source = Observable.fromArray(files)
    .filter(f -> !f.isDirectory())
    .map(f -> f.getAbsolutePath())
    .subscribeOn(Schedulers.io());

  source.subscribe(Log::i);
  CommonUtils.sleep(500);
  ```

- 결과

  ```

  ```

### 5.2.4 트램펄린 스케줄러

### 5.2.5 싱글 스레드 스케줄러

### 5.2.6 Excutor 변환 스케줄러

## 5.3 스케줄러를 활용하여 콜백 지옥 벗어나기

- 첫 번째 url로 호출하여 결과를 받은 다음, 두 번째 url로 호출하여 결과를 받는 Java 코드 작성 (비동기)
- Java 코드를 RxJava 코드로 변환

## 5.4 `observableOn()` 함수의 활용

