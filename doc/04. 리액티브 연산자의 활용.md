## 4.1 생성 연산자

### 4.1.1 `interval()` 함수

- __일정 시간 간격__으로 데이터 흐름을 생성
- 마블 다이어그램
  ![interval](images/interval.png)


- __두 가지__ 원형

  ```java
  @SchedulerSupport(SchedulerSupport.COMPUTATION)
  public static Observable<Long> interval(long period, TimeUnit unit);
  public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit);
  ```

  - `@SchedulerSupport(SchedulerSupport.COMPUTATION)`은 __계산 스케줄러__에서 실행됨을 의미
  - 영원히 지속 실행되기 때문에 __폴링__ 용도로 많이 사용됨

### 4.1.2 `timer()` 함수

- `interval()` 함수와 유사하지만 __한 번만 실행__하는 함수
- 마블 다이어그램
  ![timer](images/timer.png)


- 원형

  ```java
  @SchedulerSupport(SchedulerSupport.COMPUTATION)
  public static Observable<Long> timer(long delay, TimeUnit unit);
  ```

  - `interval()` 함수와 마찬가지로 __계산 스케줄러__에서 실행됨

### 4.1.3 `range()` 함수

- 시작 숫자(n)부터 m개의 `Integer` 객체를 발행

- 마블 다이어그램
  ![range](images/range.png)

- 원형

  ```java
  @SchedulerSupport(SchedulerSupport.NONE)
  public static Observable<Integer> range(final int start, final int count);
  ```

  - __start__부터 __count__개 만큼 루프 돌림
  - 현재 스레드에서 실행됨


### 4.1.4 `intervalRange()` 함수

- `interval()` 함수와 `range()` 함수를 혼합해 놓은 함수

- 일정 시간 간격으로 시작 숫자(n)부터 m개 만큼 데이터를 발행

- `interval()` 함수처럼 무한히 데이터를 발행하지 않음

- 마블 다이어그램
  ![intervalRange](images/intervalRange.png)

- 원형

  ```java
  @SchedulerSupport(SchedulerSupport.COMPUTATION)
  public static Observable<Long> intervalRange(long start,
                                               long count,
                                               long initialDelay,
                                               long period,
                                               TimeUnit unit);
  ```

### 4.1.5 `defer()` 함수

- `timer()` 함수와 비슷

- 데이터 흐름 생성을 구독자가 `subscribe()` 함수 호출 전까지 미룰 수 있음

- 마블 다이어그램
  ![defer](images/defer.png)

- 원형

  ```java
  @SchedulderSupport(SchedulerSupport.NONE)
  public static <T> Observable<T> defer(
    Callable<? extends ObservableSource<? extends T>> supplier);
  ```

  - `Callable<Observable<T>>` 객체를 인자로 받음
  - 때문에 구독자가 `subscribe()` 함수를 호출하기 전에 `call()` 메서드 호출을 미룰 수 있음

- `defer()` 함수의 경우 __차가운__ `Observable`

### 4.1.6 `repeat()` 함수

- 단순 반복 실행

- 서버와 통신을 할 때 해당 서버가 잘 살아있는지 확인하는 코드 때문에 한 번쯤은 사용함

- 마블 다이어그램
  ![repeat](images/repeat.png)

- 원형

  ```java
  @CheckReturnValue
  @SchedulerSupport(SchedulerSupport.NONE)
  public final Observable<T> repeat(long times)
  ```

##4.2 변환 연산자

### 4.2.1 `concatMap()` 함수

- `flatMap()` 함수와 비슷

- `flatMap()` 함수의 경우 __interleaving (끼어들기)__ 가능

- `concatMap()` 함수의 경우 들어온 순서대로 처리 (큐?)

- 마블 다이어그램
  ![concatMap](images/concatMap.png)

- 원형

  ```java
  @CheckReturnValue
  @SchedulerSupport(SchedulerSupport.NONE)
  public final <R> Observable<R> concatMap(
    Function<? super T, ? extends ObservableSource<? extends R>> mapper);
  ```

### 4.2.2 `switchMap()` 함수

- __interleaving(끼어들기)__ 상황에서 순서를 보장하기 위해 기존에 진행 중이던 작업을 바로 중단

- 여러 개의 값이 발행되었을 때 가장 마지막에 들어온 값만 처리하고 싶을 때 사용

- 마블 다이어그램
  ![switchMap](images/switchMap.png)

- 원형

  ```java
  @CheckReturnValue
  @SchedulerSupport(SchedulerSupport.NONE)
  public final <R> Observable<R> switchMap(
    Function<? super T, ? extends ObservableSource<? extends R>> mapper);
  ```

### 4.2.3 `groupBy()` 함수

- 어떠한 기준으로 단일 `Observable`을 여러 개로 이루어진 `GroupObservable`로 만듦

- 마블 다이어그램
  ![groupBy](images/groupBy.png)

- 원형

  ```java
  @SuppressWarnings({ "unchecked", "rawtypes" })
  @CheckReturnValue
  @SchedulerSupport(SchedulerSupport.NONE)
  public final <K> Observable<GroupedObservable<K, T>> groupBy(
    Function<? super T, ? extends K> keySelector);
  ```

- 예제

  ```java
  String[] objs = { "6", "4", "2-T", "2", "6-T", "4-T" };
  Observable<GroupedObservable<Shape, String>> source = 
    Observable.fromArray(objs).groupBy(Shape::fromString);

  source.subscribe(
    obj -> obj.subscribe(
      val -> System.out.println("GROUP:" + obj.getKey() + "\t Value:" + val)));
  ```

  - `getKey()` 함수로 __구분된 그룹을 알 수 있음__

### 4.2.4 `scan()` 함수

- `reduce()` 함수와 비슷

- 중간 결과 및 최종 결과를 구독자에게 발행

- 마블 다이어그램
  ![scan](images/scan.png)

- 원형

  ```java
  @CheckReturnValue
  @SchedulerSupport(SchedulerSupport.NONE)
  public final Observable<T> scan(BiFunction<T, T, T> accumulator);
  ```

  ​