## `Serializable` 인터페이스를 구현할 때는 신중하라

### 왜?

- __정보은닉__이 깨질 수 있음
- 장기적으로 해야할 일이 많아짐

### `Serializable`의 문제점

- 클래스를 릴리스하고 나면 유연하게 수정하기 어려워진다.
- __버그__나 __보안__에 취약점이 발생할 가능성이 높아진다.
- 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다.

### 클래스를 릴리스하고 나면 유연하게 수정하기 어려워진다.

- `Serializable`을 구현하면 해당 클래스의 __바이트 스트림 인코딩__이 공개됨
  즉, __공개 API__가 되어버림

- 기본 직렬화 형식을 이용하면 `private`이나 `package-private`이 의미가 없어짐

  즉, __정보은닉__이 깨짐

- __직렬화 UID__는 클래스의 진화를 막는 `Serializable`의 간단한 사례
  UID가 맞지 않으면 `InvalidClassException` 발생

### 버그나 보안에 취약점이 발생할 가능성이 높아진다.

- 직렬화/역직렬화는 __언어 외적인 객체 생성 메카니즘__
- 역직렬화는 __생성자와 동일한 이슈__를 가짐
  __모든 불변식__ 보장 X, __공격자__로 부터 보호 X

### 새 버전 클래스를 내놓기 위한 테스트 부담이 늘어난다.

- 테스트 코드로 체크가 불가능
  즉, __테스트 자동화 불가__
  why? __이진 호환성__뿐만 아니라 __의미 호환성__(원래 객체에 충실한 사본인가?)까지 체크해야 함

### 실만 있는 것은 아니다.

- 객체 전송, 저장을 위해선 필수
- 그러니, 클래스를 설계할 때 이를 꼼꼼히 따져보라.

### 주의사항

- __계승__을 염두에 둔다면 `Serializable`은 구현하지 않는 것이 바람직하다.
  - 물론 구현한 경우도 있음
    `Throwable`, `Component`, `HttpServlet` 등

  - __계승__을 고려했을 때, __위배되는 불변식__이 있는 경우 `readObjectNoData()` 메서드를 반드시 추가하라.
    `readObjectNoData()` 메서드는 Java 1.4부터 지원

    ```java
    // 상태유지 계승가능 직렬화 가능
    // 클래스에 대한 readObjectNoData() 메서드
    private void readObjectNoData() throws InvalidObjectException {
    	throw new InvalidObjectException("Stream data required");
    }
    ```

- __인터페이스__도 가급적 `Serializable`을 계승하지 마라.

- __계승__을 고려해 설계한 직렬화 불가능 클래스에는 __무인자 생성자__를 제공하는 것이 어떨지 고려하라.

- __내부 클래스__에는 `Serializable`을 구현하면 안 된다.

  - 내부 클래스의 기본 직렬화 형식은 정의될 수 없음
  - 단, __정적 멤버 클래스__는 구현해도 됨

### 정리

- `Serializable` 구현은 반드시 신중할 것