### 제네릭
- 제네릭은 __컴파일 타임에 클래스의 형태가 정해짐__

```java
public class GenericClass<T> {
	private T genericValue;

	void set(T item) {
		genericValue = item;
    }

	T get() {
		return genericValue;
    }
}
```
- 코틀린도 제네릭을 사용하는 형태는 자바와 같음

### 추론
- 자바에서는 제네릭을 `Object`로 생성하게 되면 `String` 클래스의 부모 클래스가 `Object`라도 설정해줄 수 없었음

```java
GenericClass<Object> obj = new GenericClass<>();
obj.set("aaaa"); // Error!!
```
- 코틀린은 이 부분이 에러없이 동작

```kotlin
val obj = Generic<Any>()
obj.set("Hello")
```
- 코틀린 컴파일러에서 `String` 클래스가 `Any` 클래스의 자식 클래스임을 유추하기 때문

### 와일드 카드
- 코틀린은 자바와 같이 와일드 카드 심볼이 있음
- 하지만 범위를 제한하는 방법은 다름

```java
public <T> void copy(List<T> dest, List<? extends T> src) {
	for (T item : src) {
		dest.add(item);
    }
}
```

```kotlin
fun <T> copy(dest: MutableList<T>, src: List<out T>) {
	for (item: T in src) {
		dest.add(item)
    }
}
```
- 위 코드는 상위 제한

```kotlin
class Person {
}

class PersonType<out Person> {
}
```
- 위 코드는 상위 제한을 걸어둔 제네릭 클래스

```java
public static <T> vid fill(List<? super T> list, T obj) {
	int size = list.size();

	if (size < FILL_THRESHOLD || list instanceof RandomAccess) {
		for (int i = 0; i < size; i++) {
			list.set(i, obj);
        }
    } else {
		ListIterator<? super T> itr = list.listIterator();
		for (int i = 0; i < size; i++) {
			itr.next();
			itr.set(obj);
        }
    }
}
```

```kotlin
fun <T> fill(list: MutableList<in T>, obj: T) {
	val size = list.size

	if (size < FILL_THRESHOLD || list is RandomAccess) {
		for (i in 0 until size) {
			list[i] = obj
        }
    } else {
		val itr = list.listIterator()
		for (i in 0 until size) {
			itr.next()
			itr.set(obj)
        }
    }
}
```
- 위 코드는 하위 제한

```kotlin
class Person {
}

class PersonType<in Person> {
}
```
- 위 코드는 하위 제한을 걸어둔 제네릭 클래스

### 임의적 생략
- 코틀린은 제네릭 클래스를 생성할 때 타입을 생략할 수 있는 경우와 없는 경우가 명확하게 나뉨

```kotlin
class GenericNoCon<G> {
}

class Generic<T>(val t: T) {
}

class UserGeneric {
	fun use() {
		val gen = Generic(10)
		val noCon = GenericNoCon<Int>()
    }
}
```
- __기본 생성자__를 통해 선언한 타입을 받는 경우 자동으로 타입을 유추