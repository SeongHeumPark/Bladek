### `apply()`
- `apply()` 함수는 `block`으로 __정의된 구간을 수행__하고 __사용한 객체를 다시 반환__

```kotlin
fun <T> T.apply(block: T.() -> Unit): T { block(); return this }
```
- `apply()` 함수 선언

```kotlin
fun setWindowParam() {
	window.attribute = WindowMananger.LayoutParams().apply {
		flags = WindowManager.LayoutParams.FLAG_DIM_BEHIND
		dimAmount = 0.8f
    }
}
```
- `apply()` 함수 사용 예

### `let()`
- `let()` 함수는 객체를 통해서만 실행 가능
- `run()` 함수와 유사하지만 `block` 함수를 호출할 때 __자기자신__을 넘겨 `it` 키워드로 접근 가능

```kotlin
fun <T, R> T.let(block: (T) -> R): R = block(this) // run() 함수와 비슷
```
- `let()` 함수 선언

```kotlin
convertView?.let { view ->
	view?.findViewById<View>(R.id.add).setOnClickListener {
		Toast.makeText(context, "Clicked", Toast.LENGTH_SHORT).show()
    }
}
```
- `let()` 함수 사용 예

### `with()`
- `with()` 함수는 객체를 파라미터로 넘기고 `block`을 수행하도록 함
- `with()` 함수와 `run()` 함수는 동일하다고 봐도 무방 (진짜?)

```kotlin
fun <T, R> with(receiver: T, block: T.() -> R): R = receiver.block()
```
- `with()` 함수 선언

```kotlin
with(convertView) {
	findViewById(R.id.add).setOnClickListener {
		Toast.makeText(context, "Clicked", Toast.LENGTH_SHORT).show()
    }
}
```
- `with()` 함수 사용 예
- `with()` 함수는 인자로 객체를 넘겨주기 때문에 내부에서 `null`을 체크하는 부분 필요 (?)

### `run()`
- `run()` 함수는 두 가지 형태로 사용 가능
  - `apply()` 함수처럼 객체에서 호출
  - `run()` 함수 자체로 홀로 사용
- 두 가지 경우 모두 `block` 코드에서 __수행한 결과값을 리턴__
- `run()` 함수는 `with()` 함수와 `let()` 함수를 혼합해 놓은 함수

```kotlin
fun <T, R> T.run(block: T.() -> R): R = block() // apply() 함수와 비슷
fun <R> run(block: () -> R): R = block()
```
- `run()` 함수 선언

```kotlin
convertView?.run {
	findViewById(R.id.add).setOnClickListener {
		Toast.makeText(context, "Clicked", Toast.LENGTH_SHORT).show()
    }
}
```
- `run()` 함수 사용 예

### `forEach()`
- `forEach` 함수는 `for`문과 같음
- 콜렉션에서 바로 접근 가능

```kotlin
listOf("mike", "jim", "harry").forEach {
    Toast.makeText(this, "find $it", Toast.LENGTH_SHORT).show()
}
```
- `forEach()` 함수 사용 예 1

```kotlin
fun getDataIndex(data: ArrayList<WeekList>): Int {
	val current: Long = Date().time
	(0 until data.size).forEach { i ->
        if (current < data[i].dt.toLong()) {
			return i
        }
    }

	return 0
}
```
- `forEach()` 함수 사용 예 2

### `onEach()`
- `onEach()` 함수는 __코틀린 1.1부터 사용 가능__
- `onEach()` 함수는 `forEach()` 함수와 유사
- `{}` 안의 행동의 결과값을 리턴

```kotlin
fun getListSize(list: ArrayList<Person>): Int = list.filter { it.age >= 30 } // 반드시 한 줄 띄워야 함
		.onEach {
			Toast.makeText(this, "Hello ${it.name}", Toast.LENGTH_SHORT).show()
        }.size
```
- 30세 이상의 리스트의 이름을 토스트로 출력하면서 사이즈를 리턴하는 함수
- 클린 코드에서 나왔던 __"함수는 한 가지 역할만 해야 한다."__라는 원칙을 무시하는 것이 아닐까?

### `filter()`
- `filter()` 함수는 콜렉션 장에서 설명함

```kotlin
fun addOdd(): Int {
	var result = 0
	(1..50).filter { (it % 2 - 1) == 0 }.forEach { result += it }
	return result
}
```
- `filter()` 함수 사용 예


### `lazy()` 함수와 `lateinit` 키워드
- 코틀린은 변수가 사용될 때 초기화할 수 있는 `lazy()` 함수 제공
- 변수 선언 시점이 아닌 사용 시점에 생성
- `lazy()` 함수는 `{}` 안의 코드를 실행하고 실행된 결과값을 기억하고 있다가 사용되는 시점에 돌려줌 (초기화)

```kotlin
class MainActivity : AppCompatActivity() {
	val toolbar: Toolbar by lazy {
		findViewById<Toolbar>(R.id.toolbar)
    }

	override fun onCreate(savedInstanceState: Bundle?) {
		setContentView(R.layout.activity_main)
		toolbar.setTitle("")
    }
}
```
- `lazy()` 함수 사용 예

```kotlin
class MainActivtiy : AppCompatActivity() {
	lateinit var toolbar: Toolbar

	override fun onCreate(savedInstanceState: Bundle?) {
		setContentView(R.layout.activity_main)
		toolbar.setTitle("")
    }
}
```
- `lateinit` 키워드 사용 예
- `lateinit` 키워드도 `lazy()` 함수와 비슷한 역할
- `lateinit` 키워드는 `var`에 대해서만 사용 가능
- `lateinit` 키워드는은 변수 선언 앞에 작성