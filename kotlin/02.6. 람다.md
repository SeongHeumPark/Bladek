### 람다의 형태
- 람다는 고차 함수 인자로 받아 처리하는 방법
  - 람다를 이용하면  `inline`으로 함수를 선언해서 중첩적으로 사용되는 코드를 생략하고 실행되는 코드에 집중할 수 있도록 해 줌

```kotlin
(타입 매개 변수) -> {실행문...}
```
- 람다는 `->` 기호를 사용, 함수의 선언부를 생략하고 함수의 바디 부분을 바로 작성

```kotlin
(x, y) -> x + y
```
- add 함수를 람다로 구현

```kotlin
btn.setOnClickListener((v) -> {
	// v는 인자, {} 안은 함수 바디
});
```
- onClickListener를 람다로 구현

### 코틀린에서 살펴보는 람다의 특징
- 코틀린은 람다가 표현되는 부분을 무조건 `{}`로 감싸주어야 함

 ```kotlin
val btn = findViewById(R.id.btn_hello) as Button
btn.setOnClickListener {
	btn -> showDialog()
}
 ```
- 인자를 사용하지 않는 경우 생략 가능

```kotlin
val btn = findViewById<Button>(R.id.btn_hello)
btn.setOnClickListener {
	showDialog()
}
```
- 그리고 `findViewById()` 함수 사용법이 바뀜 (__kotlin ver 1.1.51__)

```kotlin
fun printMap() {
	val map = mapOf(1 to "one", 2 to "two")
	map.forEach { _, value -> println("$value!") }
}
```
- 코틀린 1.1부터 __언더스코어 기능__이 추가됨
- 람다 함수 중에 인자 값이 여러 개면, 사용하지 않는 인자에 대해 `_`를 사용하여 처리할 수 있음

### `inline` 키워드
- `inline` 키워드를 사용하게 되면 함수 호출을 하지 않고 코드를 그대로 프로그램 중간에 삽입하여 컴파일함
  - 함수 호출 비용과 메모리를 줄일 수 있는 장점이 있음
  - `inline` 함수 길이가 길어지면 호출하는 것보다 큰 비용이 들 수 있음
  - `inline` 함수는 최대한 간결한 코드만 적용 (__c++의__ `inline`__과 같음__)

```kotlin
inline fun supportLollipop(code: () -> Unit) {
	if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
		code()
    }
}

// 호출한 부분
supportsLollipop { window.setStatusBarColor(Color.BLACK)}
```
- 함수를 인자로 받는 고차원 함수