# 03. 라이프 게임

## Description

- 관련 코드 추가
- p.230 ~ 252 까지 정리

## 관련 코드

- `Universe` 클래스

  ```java
  public class Universe extends JPanel {
  	private final Cell outermostCell;
  	private static final Universe theInstance = new Universe();

  	private static final int DEFAULT_GRID_SIZE = 8;
  	private static final int DEFAULT_CELL_SIZE = 8;

  	private Universe() {
      	outermostCell = new Neighborhood(
          	DEFAULT_GRID_SIZE, new Neighborhood(DEFAULT_GRID_SIZE, new Resident()));
      
      	// ...
      
      	addMouseListener(new MouseAdapter() {
          	@Override
          	public void mousePressed(MouseEvent e) {
              	// ...
              
              	outermostCell.userClicked(e.getPoints(), bounds);
              
              	// ...
          	}
      	})
      
      	Clock.instance().addClockListener(new Clock.Listener() {
          	@Override
          	public void tick() {
              	if (outermostCell.figureNextState(Cell.DUMMY, Cell.DUMMY, Cell.DUMMY, Cell.DUMMY,
                                                    Cell.DUMMY, Cell.DUMMY, Cell.DUMMY, Cell.DUMMY)) {
                  	if (outermostCell.transition()) {
                      	// ...
                  	}
  				}
          	}
      	});
  	}

  	public static Universe instance() {
      	return theInstance;
  	}

  	// ...
  }
  ```

- `Cell` 인터페이스

  ```java
  public interface Cell {
  	boolean figureNextState(/*Cell params*/);
  	// ...
  	boolean tansition();
  	// ...
  	void userClicked(Point here, Rectangle surface);
  	Cell create();
  	// ...

  	public static final Cell DUMMY = new Cell() {
      	// ...
  	};
  }
  ```

- `Resident` 클래스

  ```java
  public final calss Resident implements Cell {
  	// ...

  	@Override
  	private boolean figureNextState(/*Cell params*/) {
      	// ...
  	}

  	@Override
  	public boolean transition() {
      	// ...
  	}

  	// ...

  	@Override
  	public void userClicked(Point here, Rectangle surface) {
      	// ...
  	}

  	// ...

  	@Override
  	public Cell create() {
      	return new Resident();
  	}

  	// ...
  }
  ```

- `Neighborhood` 클래스

  ```java
  public final class Neighborhood implements Cell {
  	// ...

  	public Neighborhood(int gridSize, Cell prototype) {
      	this.gridSize = gridSize;
      	this.grid = enw Cell[gridSize][gridSize];
      
      	for (int row = 0; row < gridSize; ++row) {
          	for (int column = 0; column < gridSize; ++column) {
              	grid[row][column] = prototype.create();
          	}
      	}
  	}

  	@Override
  	public Cell create() {
      	return new Neighborhood(gridSize, grid[0][0]);
  	}

  	// ...

  	@Override
  	private boolean figureNextState(/*Cell params*/) {
      	// ...
      
      	for (int row = 0; row < gridSize; ++row) {
          	for (int column = 0; column < gridSize; ++column) {
              	// ...
              
              	if (grid[row][column].figureNextState(n, s, e, w, ne, nw, se, sw)) {
                  	// ...
              	}
              }
          }
  	}
    
  	@Override
  	public boolean transition() {
      	// ...
      
      	for (int row = 0; row < gridSize; ++row) {
          	for (int column = 0; column < gridSize; ++column) {
              	if (grid[row][column].transition()) {
                  	// ...
              	}
          	}
      	}
  	}

  	// ...

  	@Override
  	public void userClicked(Point here, Rectangle surface) {
      	// ...
      
      	grid[row][column].userClicked(position, subcell);
      
      	// ...
  	}
  }
  ```

## Mediator 디자인 패턴

### 정의

- 객체들 간의 __상호 작용__을 __캡슐화__

### 특징

- __양방향__
- __Colleague__
  Mediator가 이야기 나누는 다른 시스템

### 효과

- Colleagues 간의 __결합도 감소__

### `Universe` 클래스

- Mediator 패턴의 예
- __스윙 ↔ 라이프 서브시스템__의 __중개자__

###  Mediator vs. Facade

- 많은 개발자들이 두 패턴은 혼동

  | Mediator         | Facade          |
  | ---------------- | --------------- |
  | 상호 작용을 캡슐화 (양방향) | 단순화 인터페이스 (단방향) |


## Prototype 디자인 패턴

### 정의

- __프로토 타입__이 되는 객체를 __cloning__하여 생성

### 효과

- __복잡도 감소__
- __생성한 후 수정하기 문제 해결__

### Command + Abstract Factory vs. Prototype

- `Universe` 클래스는 `Cell`을 중첩해서 생성한다.
  ![그림1](C:\Users\Naver\Desktop\그림1.png)
  - __문제점__
    - `Cell` 인터페이스를 구현한 `Neighborhood`, `Resident` 클래스를 `Universe` 클래스에서 생성할 때 발생
  - __해결책__
    1. __Command + Abstract Factory 패턴__
    2. __Prototype 패턴__

#### Command + Abstract Factory 패턴으로 생성

- `Neighborhood` 클래스
  ```java
  public final class Neighborhood {
  	interface CellFactory {
    		Cell create();
  	}

  	// ...

  	public Neighborhood(int gridSize, CellFactory factory) {
    		for (int row = 0; row < gridSize; ++row) {
        		for (int column = 0; column < gridSize; ++column) {
            		grid[row][column] = factory.create();
        		}
    		}
  	}

  	// ...
  }
  ```

- `Universe` 클래스

  ```java
  public class Universe {
  	// ...

  	public Universe() {
      	outermostCell = new Neighborhood(DEFAULT_GRID_SIZE, new Creator() {
          	@Override
          	public Cell creator() {
              	return new Neighborhood(DEFAULT_GRID_SIZE, new Creator() {
                  	@Override
                  	public Cell creator() {
                      	return new Resident()
                  	}
              	});
          	}
      	});
  	}

  	// ...
  }
  ```


#### Command + Abstract Factory 패턴 문제점

- 코드가 복잡해 진다. __(복잡성 ↑)__
- 생성한 객체가 __디폴트__가 아닌 경우도 고려해야 한다. __(생성 후 수정 필요)__

#### Prototype 패턴으로 생성

- 코드는 __관련 코드__ 참고
- __복잡성__, __생성 후 수정__에 대한 문제점을 해결

#### Prototype 패턴에서 `clone()` 함수 대신 `create()` 함수를 사용

- 개발자 취향
- `clone()` 함수는 `Object`를 반환하기 때문에 __캐스팅__이 필요 (__타입 안정성 고려 X__)

## Composite 디자인 패턴



## Flyweight 디자인 패턴



## Flyweight 풀



