### 생성자 `constructor` 키워드
- 코틀린은 생성자를 만드는데 자바와 차이가 있음
```Kotlin
class Person(name: String, age: Int) {
	// ...
}
```
- 클래스 선언부에서 __기본 생성자__ 정의

```kotlin
class Person() {
	// 기본 생성자의 인자가 없는 경우
	constructor(name: String, age: Int): this()

	// ...
}

class Person(name: String) {
	// 기본 생성자의 인자가 있는 경우
	constructor(name: String, age: Int): this(name)

	// ...
}
```
- 여러 개의 생성자를 선언해야 하는 경우 `constructor` 키워드를 사용
- `this()` 함수를 불러주는 문법 추가
  - 기본 생성자 외의 생성자는 `this(params)`라는 함수를 __꼭 호출해야 함__
  - `this()` 함수는 __기본 생성자의 속성__을 __상속 받아 처리__되는 형식이라고 생각하면 됨

```kotlin
var person: Person = Person("Peter")
var person: Person = Person("Bill", 13)
```
- 객체를 생성할 때 `new` 키워드를 사용하지 않음


### 생성자 기본값 설정하기

- 코틀린은 생성자에 기본 값을 적용할 수 있음

```kotlin
class Person(name: String = "No Name", age: Int = 0) {
	// ...
}
```

- _생성자 기본값의 범위_

  ```kotlin
  var defaultPerson: Person = Person()
  var namePerson: Person = Person("jame")
  var person: Person = Person("mike", 23)
  var agePerson: Person = Person(45) // error!!
  ```

  - 모든 경우에 대해 자동 mapping 해주지 않음

### 생성자 함수 바디를 가질 수 없을까?

```kotlin
class Person(var name: String?, var age: Int = 0) {
	// ...
}
```

- __기본 생성자__가 클래스 선언부에 정의되므로 바디를 가질 수 없는 구조처럼 보임

```kotlin
class Person(var name: String?, var age: Int = 0) {
	init {
		if (name.isNullOrBlank()) {
			name = "No Name"
        }
    }

	// ...
}
```

- `init{}` 함수를 사용하면 기본 생성자의 인자들을 처리할 수 있음

### `var`과 `val`

|    var    |         val         |
| :-------: | :-----------------: |
|  수정이 가능   |       수정이 불가능       |
| 항상 타입을 명시 | 스마트 타입 캐스팅 or 타입 명시 |

- 코틀린은  `val` 키워드를 사용하기를 권장
  __why?__ 의도치 않은 변경을 방지하기 위해
- 함수 인자에 `var`, `val`를 명시하지 않으면 __기본적으로__ `val`__로 인식__

### 접근 제한자

|    자바     |    코틀린    |
| :-------: | :-------: |
|  private  |  private  |
| protected | protected |
|     -     | internal  |
|  public   |  public   |

- `internal` 외의 제한자는 자바와 같음
- `internal`은 클래스나 변수는 __같은 모듈__에 한해서 __접근이 가능__하도록 해주는 제한자
  - __모듈__?
    - __자바__: 기능이 비슷한 클래스들의 집합체
    - __코틀린__: 동일한 컴파일의 집단
      정확히는 __IntelliJ로 컴파일되는 모듈__ or __maven__, __gradle에 묶여서 같이 컴파일되는 파일 전체__

```kotlin
open class OuterClass {
	private val a = 1
	protected val b = 2
	internal val c = 3
	val d = 4 // public
}
```

- 코틀린은 변수 선언시, 접근 제한자를 정의하지 않으면  `public`으로 간주

### 클래스의 멤버 변수 선언

- 코틀린은 변수 선언 시, 컴파일러가 자동으로 `get()`/`set()`을 생성함

```kotlin
class Person() {
	var name: String = ""
	get() = "Name : " + field
  
	var age: Int = 0
	set(age) {
		field = +1
    }
}

class MainActivity : Activity() {
	override fun onCreate(saveInstance: Bundle) {
		var person: Pseron = Person()
		person.name = "Mike"
		person.age = 20
    }
}
```

- 위 `Person` 클래스처럼 `get()`/`set()`을 __오버라이딩__ 할 수 있음
- 오버라이딩시 변수의 접근은 `field` 키워드를 사용함
- `get()`/`set()`의 접근 제한자는 변수의 접근 제한자를 따름

```kotlin
class Person(name: String, age: Int) {
	var name: String = ""
	private set

	var age: Int = 0
	private set
}

class MainActivity : Activity() {
	override fun onCreate(saveInstance: Bundle) {
		var person: Person = Person("Mike", 20) // error!!
		person.name = "Peter" // error!!
    }
}
```

- 위 코드는 외부에서 `Person` 객체의 데이터를 조작하지 못하게 함

### 상속

- 코틀린은 상속을 `:`로 표현
- 어떤 클래스의 상속을 허용하려면 `open`이나 `abstrat` 키워드를 사용해야 함
  - `open`: 부모 클래스
  - `abstrac`: 추상화 클래스

```kotlin
public open class Any {
	public open operator fun equals(other: Any?): Boolean

	public open fun hasCode(): Int

	public open fun toString(): String
}
```

- 자바의 `Object` 클래스와 마찬가지로 코틀린은 `Any` 클래스가 있음

```kotlin
open class Figure(vertex: Int) {
	open fun onFinishDraw() {}

	fun onDraw() {}
}

class Triangle : Figure(3) {
	override fun onFinishDraw() {}

	override fun onDrwa() {} // error!!
}
```

- 코틀린은 함수를 선언할 때 기본적으로 `final`임
- 오버라이딩을 허용해 주려면 `open` 키워드를 사용해야 함

```kotlin
// 부모 클래스의 생성자가 여러 개일 때 처리 방법 1
class CustomDialog(context: Context) : AlertDialog(context) {
}

// 부모 클래스의 다른 생성자를 호출하는 케이스
class CustomDialog(context: Context) : AlertDialog(context) {
	constructor(context: Context, themeId: Int): super(context, themeId) // error!!
}
```

```kotlin
// 부모 클래스의 생성자가 여러 개일 때 처리 방법 2
class CustomDialog : AlertDialog {
	constructor(context: Contxt): super(context)
}

// 부모 클래스의 다른 생성자를 호출하는 케이스
class CustomDialog : AlertDialog {
	constructor(context: Context): super(context, R.style.Theme_NoTitleBar_FullScreen)
	constructor(context: Context, themeId: Int): super(context, themeId)
}
```

- 부모 클래스의 생성자가 여러 개인 경우 __확장성__이나 __사용성__ 측면에서 2번 방법으로 처리하는 것이 BEST

### `interface` 클래스

- 코틀린은 `interface` 클래스 내부의 __함수가 바디를 가질 수 있음__
- `get()`/`set()`을 통해 값을 지정할 수 있음
- `interface` 클래스의 구현은 `:`로 표현

```kotlin
interface FinishDraw {
	var distance: Int
	open fun onFinishDraw()
}

open class Figure(var vertex: Int) : FinishDraw {
	override var distance: Int
		get() = vertex
		set(value) {
    	}
  
	override fun onFinishDraw() {
    }
}
```

- `interface` 클래스에서 `get()`을 선언하지 않는 경우, 구현 클래스에서 무조건 변수를 __오버라이딩__해야 함
- 좀 더 복잡한 케이스

```kotlin
open class A {
	open fun f() {}
	fun a() {}
}

interface B {
	fun f() {}
	fun b() {}
}

class C : A(), B {
	override fun f() {
		super<A>.f()
		super<B>.f()
    }
}
```

- __함수명이 같은__ 클래스들을 상속 받아 함수를 오버라이딩할 때 __부모 클래스의 이름을 명시적__으로 적어줘야 함

### 그 밖의 클래스 타입

#### `data` 클래스

- 클래스 중에 __데이터만__ 갖는 클래스
- 반드시 __기본 생성자__를 선언해야 함
- __기본 생성자__의 인자는 `var`나 `val` 키워드를 반드시 사용해야 함

```kotlin
data class Person(var name: String, var age: Int)
```

- 일부 변수만 변경하여 복사하고 싶은 경우 `copy()` 함수를 사용하면 됨

```kotlin
data class Person(var name: String, var age: Int)

val person: Person = Person("jame", 30)
val oldone: Person = Person.copy(age = 45)
```

#### `enum` 클래스

```kotlin
enum class Color(val rgb: Int) {
	RED(0xFF0000),
	GREEN(0x00FF00),
	BLUE(0x0000FF)
}
```

- 코틀린은 `enum` 클래스 초기화 코드를 __클래스 이름과 함께 선언 가능__

#### `sealed` 클래스

- __상속을 제한__하기 위해 사용하는 클래스

```kotlin
sealed class Expression {
}

data class Sum(val num1: Int, val num2: Int) : Expression() // ok
```

```kotlin
data class Const(val num: Int): Expression() // error!!

class MainActivity : Activity() {
	override fun onCreate(saveInstanceState: Bundle) {
		super.onCreate(saveInstanceState)
		setContentView(R.layout.activity_main)
    }
}
```

- 외부 파일에서 `sealed` 클래스를 접근할 경우 `private`이라 상속할 수 없다고 에러가 남
- 같은 프로젝트 안에 있다면 `sealed` 클래스를 상속 받은 자식 클래스는 어느 파일에 위치하든 상관없음 __???__

#### `object` 타입

- __anonymous 클래스__를 선언해야 할 경우, 코틀린은 이를 받아주는 `object`라는 객체가 따로 있음
- 함수 인자의 anonymous 클래스로 구현한 경우

```kotlin
val webView = WebView(context)
webView.setWebViewClient(object : WebViewClient() {
	override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
		super.onPageStarted(view, url, favicon)
    }
})
```

- 일회용 클래스를 anonymous 클래스로 구현한 경우

```kotlin
interface Shape {
	fun onDraw()
}

val triangle = object : Shape {
	override fun onDraw() {
		// ...
    }
}
```

- 함수 리턴을 anonymous 클래스로 구현한 경우

```kotlin
class C {
	private fun getValue() = object {
		val x: String = "x"
    }

  	fun getPublicValue() = object {
		val x_p: String = "x_p"
    }

	fun bar() {
		getValue().x
		getPublicValue().x_p // error!!
    }
}
```

- `getPublicValue()` 함수의 경우 `object`가 `Any`로 변경되면서 __return 값을 선언하지 않는 것과 같이 동작__(결국 void ???)
  __why?__ 클래스 내부에 선언되어 있는 값을 외부에서 건들 수 없게 하기 위해