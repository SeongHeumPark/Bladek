### 타입 체크 `is`와 타입 캐스팅 `as`
- 코틀린은 타입 체크 `is`와 타입 캐스팅 `as` 키워드를 가지고 있음

``` kotlin
override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View? {
	val view: View?
	val holder: ViewHolder

	if (convertView?.getTag() is ViewHolder) {
		view = convertView
		holder = view.tag as ViewHolder
    } else {
		view = inflater.inflate(R.layout.datahome_item_total_list_item, parent, false)
		holder = ViewHolder(view)

		view.tag = holder
    }

	return view
}

class ViewHodler(view: View) {
	// ...
}
```
- `is`는 자바의 `instanceof`와 같음
- `as`는 `(type) 변수`와 같음

### NPE에 안전한 변수 선언 방법
- 코틀린의 가장 큰 장접은 __null safty 구조를 지향__

```kotlin
var a: String = "abc"
a = null // error!!
```
- 일반적인 변수 선언으론 `null`을 가질 수 없음

```kotlin
var a: String? = "abc"
a = null // ok

// warning!
val len: Int = a.length
```
- `?` 기호로 변수를 선언하면 `null`을 가질 수 있음
- 이 경우 개발자에게 지속적으로 NPE 처리를 요구하게 됨

```kotlin
// ok
val len: Int = a?.length
```
- NPE 처리는 `?` 기호로 처리함
- `null`이 아닌 경우에만 처리됨

```kotlin
var len: Int = a?.length?:0
```
- `null`일 때 기본값을 설정해줄 수 있음
- `?:` __엘비스 연산자__를 사용

```kotlin
var a: String? = "abc"
a = null
val len: a!!.legnth // error!!
```
- `!!`기호는 명시적으로 `null` 값을 참조할 수 없도록 해줌
- `null` 값을 참조하면 런타임에 예외가 발생함

### 비교 연산자 `==`와 `===`
- `===` 연산자는 두 변수의 자료 포인터가 정말 같은지 살펴보는 기능을 함
- `==` 연산자는 자바의 것과 같음

```kotlin
a?.equals(b) ?: (b === null)
```
- 그러나 내부적으로는 다름
- 주의해야 할 부분은 `a`와 `b`가 `null`인 경우 `true`를 반환함